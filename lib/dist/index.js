var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{$:()=>j});class n{constructor(t){this.onChange=t,this._soma="#444",this._axon="#00f",this._apicalDendrite="#f0f",this._basalDendrite="#f00",this._unknown="#888"}get soma(){return this._soma}set soma(t){t!==this._soma&&(this._soma=t,this.fire())}get axon(){return this._axon}set axon(t){t!==this._axon&&(this._axon=t,this.fire())}get apicalDendrite(){return this._apicalDendrite}set apicalDendrite(t){t!==this._apicalDendrite&&(this._apicalDendrite=t,this.fire())}get basalDendrite(){return this._basalDendrite}set basalDendrite(t){t!==this._basalDendrite&&(this._basalDendrite=t,this.fire())}get unknown(){return this._unknown}set unknown(t){t!==this._unknown&&(this._unknown=t,this.fire())}fire(){this.onChange(this)}}const i=function*(t){const e=t.length;let n=0,i=0;for(;n>-1&&n<e&&(n=t.indexOf("\n",i),!(n<0));)yield t.substring(i,n).trim(),i=n+1;return t.substring(i).trim()};function s(t){return 3===t.length}function r(t,e){const n=[];if(e)for(let i=0;i<t;i++)n.push(e(i));else for(let e=0;e<t;e++)n.push(e);return n}var a,o;!function(t){t[t.X=0]="X",t[t.Y=1]="Y",t[t.Z=2]="Z",t[t.W=3]="W"}(a||(a={}));class h{constructor(t,e=0){this.divisor=e,this.buffer=null,this.arrayBuffer=null,this.data={},this.verticeCount=0;let n=0;const i={},s={};for(const r of Object.keys(t)){i[r]=new ArrayBuffer(0);const a=c(t[r],e,n);s[r]=a,n+=a.bytesPerElement*a.dimension}this.data=i,this.definitions=s,this.stride=n}getVerticeCount(){return this.verticeCount}debug(){const{definitions:t,verticeCount:e}=this;console.log("Vertices count:",e);const n=new Float32Array(this.get());console.log(n);for(const n of Object.keys(t)){const i=t[n];console.log(n,r(e).map((t=>r(i.dimension).map((e=>this.peek(n,t,e))))))}}getNames(){return Object.keys(this.definitions)}getDefinitions(){return structuredClone(this.definitions)}getAttribDef(t){const e=this.definitions[t];return e?structuredClone(e):void 0}getGlslType(t){const e=this.definitions[t];if(!e)return`/* "${t}" not found! */`;switch(e.dimension){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:return`/* Don't know how to deal with dimension ${e.dimension}! */`}}get(t=0){const e=t>0?t:this.verticeCount,n=this.stride*e;if(!this.arrayBuffer||this.arrayBuffer.byteLength<n){this.checkIfWeHaveEnoughData(e),this.arrayBuffer=new ArrayBuffer(n);const t=new DataView(this.arrayBuffer);let i=0;const{data:s,definitions:r}=this;for(let n=0;n<e;n++)for(const e of Object.keys(r)){const a=r[e],o=s[e],h=new DataView(o);let c=a.bytesPerElement*a.dimension*n;for(let e=0;e<a.dimension;e++)a.setter(t,i,a.getter(h,c)),c+=a.bytesPerElement,i+=a.bytesPerElement}}return this.arrayBuffer}update(t,e=0,n=!1){const i=this.getBuffer(),s=e>0?e:this.verticeCount,r=this.get(s);return t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,r,n?t.DYNAMIC_DRAW:t.STATIC_DRAW),r}define(t,e){const{buffer:n}=this;n&&t.bindBuffer(t.ARRAY_BUFFER,n);let i=0;const{definitions:s}=this;for(const n of Object.keys(s)){const r=s[n],a=t.getAttribLocation(e,n);if(a<0)throw Error(u(n));t.enableVertexAttribArray(a),t.vertexAttribPointer(a,r.dimension,t.FLOAT,!1,this.stride,i),t.vertexAttribDivisor(a,r.divisor),i+=r.dimension*r.bytesPerElement}}set(t,e){var n;(n=e)&&"object"==typeof n&&e.buffer instanceof ArrayBuffer&&(e=e.buffer),this.data[t]=e;const{bytesPerElement:i,dimension:s}=this.definitions[t];this.verticeCount=Math.max(this.verticeCount,Math.ceil(e.byteLength/(i*s))),this.arrayBuffer=null}poke(t,e,n,i){if(e>=this.verticeCount)return;const s=this.get(this.verticeCount),r=new DataView(s),{setter:a,bytesPerElement:o,bytesOffset:h}=this.definitions[t];a(r,h+e*this.stride+o*n,i)}peek(t,e,n){if(e>=this.verticeCount)return 0;const i=this.get(this.verticeCount),s=new DataView(i),{getter:r,bytesPerElement:a,bytesOffset:o}=this.definitions[t];return r(s,o+e*this.stride+a*n)}getBuffer(){const{buffer:t}=this;if(!t)throw Error(`Wgl2Attribute.buffer has not been set!\n${JSON.stringify(this.definitions,null,"  ")}`);return t}checkIfWeHaveEnoughData(t){const{data:e,definitions:n}=this;for(const i of Object.keys(n)){const s=e[i];if(!s)throw Error(`No data has been set for attribute "${i}"!\nPlease use something like this:\n    data.set("${i}", new Float32Array([4, 3]))`);const r=n[i],a=r.bytesPerElement*r.dimension*t;if(s.byteLength<a)throw Error(`Attribute "${i}" has only ${s.byteLength} bytes, but we need at least ${a} since you asked for ${t} vertices!`)}}}function c(t,e,n){const i="number"==typeof t?{dimension:t,type:"float"}:Object.assign({type:"float",dimension:1},t);if("float"===i.type)return function(t,e,n){const i=Float32Array.BYTES_PER_ELEMENT;return{dimension:t.dimension,divisor:e,bytesPerElement:i,bytesOffset:n,getter:(t,e)=>t.getFloat32(e,!0),setter(t,e,n){t.setFloat32(e,n,!0)}}}(i,e,n);throw Error(`Unable to create a Data for an attribute of type "${i.type}"!`)}function u(t){return`Unable to find atribute "${t}"!`}function l(t){const e=t.indexOf("#");return e<0?t:t.substring(0,e).trim()}function f(t){return(function(t){switch(t){case o.Soma:return 0;case o.Axon:return 1;case o.ApicalDendrite:return 2;case o.BasalDendrite:return 3;default:return 4}}(t)+.5)/5}!function(t){t[t.Soma=1]="Soma",t[t.Axon=2]="Axon",t[t.BasalDendrite=3]="BasalDendrite",t[t.ApicalDendrite=4]="ApicalDendrite",t[t.Unknown=666]="Unknown"}(o||(o={}));class d{constructor(t){this.nodes=t,this._count=0,this.nodesXYZR=[],this.nodesUV=[],this.nodesInfluence=[],this.attAxyzr=[],this.attBxyzr=[],this.attAuv=[],this.attBuv=[],this.attAinfluence=[],this.attBinfluence=[],this.elemByIndex=new Map,t.forEach((({index:t,type:e,x:n,y:i,z:s,radius:r,u:a,v:h})=>{const c=this.nodesUV.length;this.nodesXYZR.push([n,i,s,r]),this.nodesUV.push([a,h]),this.nodesInfluence.push(e===o.Soma?0:1),this.elemByIndex.set(t,c)}))}get count(){return this._count}addSegment(t,e){const n=this.elemByIndex.get(t);if("number"!=typeof n)return;const i=this.elemByIndex.get(e);if("number"!=typeof i)return;const s=this.nodesXYZR[n],r=this.nodesXYZR[i];this.attAxyzr.push(...s),this.attBxyzr.push(...r);const a=this.nodesUV[n],o=this.nodesUV[i];this.attAuv.push(...a),this.attBuv.push(...o),this.attAinfluence.push(this.nodesInfluence[n]),this.attBinfluence.push(this.nodesInfluence[i]),this._count++}makeAttributes(t=1){const e=new h({attAxyzr:4,attBxyzr:4,attAuv:2,attBuv:2,attAinfluence:1,attBinfluence:1},t);return e.set("attAxyzr",new Float32Array(this.attAxyzr)),e.set("attBxyzr",new Float32Array(this.attBxyzr)),e.set("attAuv",new Float32Array(this.attAuv)),e.set("attBuv",new Float32Array(this.attBuv)),e.set("attAinfluence",new Float32Array(this.attAinfluence)),e.set("attBinfluence",new Float32Array(this.attBinfluence)),e}}function v(t,e){const n=document.createElement("canvas");if(!n)throw Error("Unable to create a HTMLCanvasElement!");n.width=t,n.height=e;const i=n.getContext("2d");if(!i)throw Error("Unable to create a 2D context!");return i}class m{constructor(t,e,n){this.resources=t,this.camera=n,this.gl=null,this.prg=null,this.vao=null,this.texture=null,this.locations={},this.instancesCount=0,this._radiusMultiplier=1,this._radiusType=0,this._colorBy="section",this.textureIsOutOfDate=!0,this.paint=t=>{const e=1-this._radiusType,n=this._radiusType,{gl:i,camera:s,locations:r,textureIsOutOfDate:a,texture:o,colorBy:h}=this;i&&(s.viewport.width=i.drawingBufferWidth,s.viewport.height=i.drawingBufferHeight,i.useProgram(this.prg),o&&a&&(i.bindTexture(i.TEXTURE_2D,o),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,"section"===h?function({soma:t="#444",axon:e="#00f",apicalDendrite:n="#f0f",basalDendrite:i="#f00",unknown:s="#888"}={}){const r=v(1,5);return[t,e,i,n,s].forEach(((t,e)=>{r.fillStyle=t;const n=e;r.fillRect(0,n,1,n+1)})),r.canvas}(this.colors):function(){const t=v(256,1),e=["#0f0","#ff0","#f00"],n=t.createLinearGradient(0,0,256,1);return e.forEach(((t,i)=>{n.addColorStop(i/(e.length-1),t)})),t.fillStyle=n,t.fillRect(0,0,256,1),t.canvas}()),this.textureIsOutOfDate=!1),s.setUniforms(i,r.uniModelViewMatrix,r.uniProjectionMatrix),i.uniform1f(r.uniAspect,i.drawingBufferWidth/i.drawingBufferHeight),i.enable(i.DEPTH_TEST),i.clearDepth(1),i.depthFunc(i.LESS),i.depthMask(!0),i.depthRange(0,1),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT),i.bindVertexArray(this.vao),i.uniform1f(r.uniRadiusMultiplier,this._radiusMultiplier*e),i.uniform1f(r.uniRadiusAdditioner,this.averageRadius*this._radiusMultiplier*n),i.uniform1f(r.uniLightness,1),i.uniform1f(r.uniZFight,0),i.uniform1f(r.uniOutline,1),i.drawElementsInstanced(i.TRIANGLES,48,i.UNSIGNED_BYTE,0,this.instancesCount),i.uniform1f(r.uniOutline,1.2),i.uniform1f(r.uniLightness,0),i.uniform1f(r.uniZFight,1),i.drawElementsInstanced(i.TRIANGLES,48,i.UNSIGNED_BYTE,0,this.instancesCount))},this.handleResize=()=>{const{canvas:t,gl:e}=this,n=t.clientWidth,i=t.clientHeight;t.width=n,t.height=i,null==e||e.viewport(0,0,n,i),this.refresh()};const{gl:r}=t;this.gl=r,this.observer=new ResizeObserver(this.handleResize);const a=r.canvas;if(!(a instanceof HTMLCanvasElement))throw Error("This painter works only with a real HTMLCanvasElement!");this.canvas=a,this.observer.observe(a),this.resources=t,this.averageRadius=e.averageRadius;const o=t.createProgram({vert:"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uniTexture;\nuniform mat4 uniModelViewMatrix;\nuniform mat4 uniProjectionMatrix;\nuniform float uniAspect;\nuniform float uniRadiusMultiplier;\nuniform float uniRadiusAdditioner;\nuniform float uniOutline;\nuniform float uniLightness;\nuniform float uniZFight;\nin vec4 attAxyzr;\nin vec4 attBxyzr;\nin vec2 attAuv;\nin vec2 attBuv;\nin float attAinfluence;\nin float attBinfluence;\nin float attCenter;\nin vec2 attOffset;\nout vec3 varColor;\n\nconst float EPSILON = 1e-5;\n\nfloat scaleRadius(float radius, float influence) {\n    float multiplier = mix(1.0, uniRadiusMultiplier, influence);\n    float additioner = uniRadiusAdditioner * influence;\n    return (radius * multiplier + additioner) * mix(1.0, uniOutline, influence);\n}\n\nvec2 safeNormalize(vec2 v) {\n    float len2 = dot(v, v);\n    if (len2 < 1e-6) return vec2(0, 1);\n\n    return inversesqrt(len2) * v;\n}\n\nvoid main() {\n    vec2 uv = attCenter == 0.0 ? attAuv : attBuv;\n    varColor = texture(uniTexture, uv).rgb * uniLightness;\n\n    vec3 vecRadius = vec3(\n        0.0,\n        attCenter == 0.0 \n            ? scaleRadius(attAxyzr.w, attAinfluence) \n            : scaleRadius(attBxyzr.w, attBinfluence), \n        0.0\n    );\n    vec4 cameraA = uniModelViewMatrix * vec4(attAxyzr.xyz, 1.0);\n    vec4 screenA = uniProjectionMatrix * cameraA;\n    vec4 cameraA2 = uniModelViewMatrix * vec4(attAxyzr.xyz + vecRadius, 1.0);\n    vec4 screenA2 = uniProjectionMatrix * cameraA2;\n    vec4 cameraB = uniModelViewMatrix * vec4(attBxyzr.xyz, 1.0);\n    vec4 screenB = uniProjectionMatrix * cameraB;\n    vec4 cameraB2 = uniModelViewMatrix * vec4(attBxyzr.xyz + vecRadius, 1.0);\n    vec4 screenB2 = uniProjectionMatrix * cameraB2;\n    // Is A or B the center here?\n    vec4 center = attCenter == 0.0 ? screenA : screenB;\n    float radius = 1e-2 * (\n        attCenter == 0.0 \n            ? length(cameraA - cameraA2) \n            : length(cameraB - cameraB2)\n    );\n    // 2D Axis in screen space: screenAxisY is aligned with the segment\n    // from A to B.\n    // Note: with orthographic camera, both screenA.z and screenB.z\n    // will be equal to 1.0.\n    vec2 screenAxisY = safeNormalize(screenB.xy / screenB.z - screenA.xy / screenA.z) * radius;\n    vec2 screenAxisX = vec2(screenAxisY.y, -screenAxisY.x);\n    // Each point is offset from a center.\n    // This allows thickness variation in the shader.\n    vec2 screenOffset = attOffset.x * screenAxisX + attOffset.y * screenAxisY;\n    center.x += screenOffset.x;\n    center.y += screenOffset.y * uniAspect;\n    // Prevent Z fight.\n    center.z += uniZFight * EPSILON; // EPSILON * (attCenter + uniZFight);\n    gl_Position = center;\n}\n",frag:"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uniTexture;\n\nin vec3 varColor;\nout vec4 FragColor;\n\n\nvoid main() {\n    FragColor = vec4(varColor, 1.0);\n}\n"});this.prg=o,this.locations=t.getUniformsLocations(o);const{attributes:c,elements:u}=function(){const{vertices:t,faces:e}=function(t){const e=[],n=[];for(const t of i("# Blender 4.0.1\n# www.blender.org\no Circle\nv 0.000000 2.000000 0.000000\nv -0.500000 1.866025 0.000000\nv -0.866025 1.500000 0.000000\nv -1.000000 1.000000 0.000000\nv -0.500000 -1.933013 0.000000\nv -0.866025 -1.566987 0.000000\nv -1.000000 -1.066987 0.000000\nv 1.000000 -1.066987 0.000000\nv 0.866025 -1.566987 0.000000\nv 1.000000 1.000000 0.000000\nv 0.866025 1.500000 0.000000\nv 0.500000 1.866025 0.000000\nv 0.500000 -1.933013 0.000000\nv -0.000000 -2.066987 0.000000\nv 0.000000 1.000000 0.000000\nv 0.000000 -1.066987 0.000000\ns 0\nf 3 15 4\nf 2 15 3\nf 1 15 2\nf 12 15 1\nf 11 15 12\nf 10 15 11\nf 9 16 8\nf 13 16 9\nf 14 16 13\nf 5 16 14\nf 6 16 5\nf 7 16 6\nf 4 16 7\nf 4 15 16\nf 16 15 8\nf 15 10 8\n")){if(t.startsWith("v ")){const n=t.substring(2).split(" ").map((t=>Number(t)));s(n)&&e.push(n)}if(t.startsWith("f ")){const e=t.substring(2).split(" ").map((t=>Number(t)-1));if(!s(e))throw Error(`This simple Wavefront parser accepts only triangles!\n${t}`);n.push(...e)}}return{vertices:e,faces:n}}(),n=new h({attCenter:1,attOffset:2}),r=[],a=[];for(const[e,n]of t){const t=n>0;r.push(t?1:0),a.push(e,n-(t?1:-1))}return n.set("attCenter",new Float32Array(r)),n.set("attOffset",new Float32Array(a)),{attributes:n,elements:new Uint8Array(e)}}(),l=new d(e);e.forEach((({index:t,parent:e,type:n,radius:i,x:s,y:r,z:a})=>{e<0||l.addSegment(t,e)})),this.instancesCount=l.count;const f=l.makeAttributes();this.vao=t.createVAO(o,c,f,new Uint8Array(u)),r.clearColor(1,1,1,1),this.texture=function(t){const e=t.createTexture();if(!e)throw Error("Unable to create a WebGLTexture!");return t.activeTexture(t.TEXTURE0+0),t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),e}(r)}get colorBy(){return this._colorBy}set colorBy(t){t!==this._colorBy&&(this._colorBy=t,this.textureIsOutOfDate=!0,this.refresh())}get radiusType(){return this._radiusType}set radiusType(t){t!==this._radiusType&&(this._radiusType=t,this.refresh())}get radiusMultiplier(){return this._radiusMultiplier}set radiusMultiplier(t){this._radiusMultiplier!==t&&(this._radiusMultiplier=t,this.refresh())}cleanUp(){this.resources.cleanUp(),this.observer.unobserve(this.canvas)}resetColors(t){this.textureIsOutOfDate=!0,this.colors=t}refresh(){window.requestAnimationFrame(this.paint)}}var p=1e-6,g="undefined"!=typeof Float32Array?Float32Array:Array;function y(){var t=new g(3);return g!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function x(t){var e=new g(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function w(t,e,n){var i=new g(3);return i[0]=t,i[1]=e,i[2]=n,i}function b(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t}function E(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t}function A(t,e,n){var i=e[0],s=e[1],r=e[2];return t[0]=i*n[0]+s*n[3]+r*n[6],t[1]=i*n[1]+s*n[4]+r*n[7],t[2]=i*n[2]+s*n[5]+r*n[8],t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var _;y();class B{constructor(t){this.nodes=t,this.nodesByIndex=new Map;let e=0,n=0;t.forEach((t=>{t.type!==o.Soma&&(e+=t.radius,n++),this.nodesByIndex.set(t.index,t)})),this.averageRadius=0===n?0:e/n,t.forEach((t=>{0===t.radius&&(t.radius=this.averageRadius)}));const{center:i,bbox:s}=function(t){const[e]=t;if(!e)throw Error("Unable to compute bounding box because the nodes array is empty!");const n=w(e.x,e.y,e.z),i=x(n),s=x(n),r=x(n);let a=1;for(const{x:u,y:l,z:f,radius:d,index:v,type:m,parent:p}of t){if(v===e.index)continue;const t=w(u,l,f);-1===p&&(c=t,(h=n)[0]=c[0],h[1]=c[1],h[2]=c[2]),m===o.Soma&&(b(r,r,t),a++),i[0]=Math.min(i[0],t[0]-d),s[0]=Math.max(s[0],t[0]+d),i[1]=Math.min(i[1],t[1]-d),s[1]=Math.max(s[1],t[1]+d),i[2]=Math.min(i[2],t[2]-d),s[2]=Math.max(s[2],t[2]+d)}var h,c;return function(t,e,n){t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n}(r,r,1/a),E(i,i,r),E(s,s,r),{center:[...r],bbox:[Math.max(Math.abs(i[0]),Math.abs(s[0])),Math.max(Math.abs(i[1]),Math.abs(s[1])),Math.max(Math.abs(i[2]),Math.abs(s[2]))]}}(t);this.center=i,this.bbox=s,this.tree=this.buildTree()}getByIndex(t){return this.nodesByIndex.get(t)}forEach(t){this.nodes.forEach(t)}computeDistancesFromSoma(){const{nodes:t}=this,e=new Map,n=new Map;t.forEach((t=>e.set(t.index,t)));let i=0;if(t.forEach((t=>{const s=M(t,e,n);t.u=s,i=Math.max(i,s)})),0===i)return;const s=1/i;t.forEach((t=>t.u*=s))}buildTree(){const{nodes:t}=this;if(0===t.length)throw Error("There are no nodes in this file!");let[e]=t;const n=new Map;t.forEach((t=>{const i={node:t,children:[]};if(n.set(t.index,i),-1===t.parent)e=t;else if(t.index===t.parent)console.error(`Node #${t.index} has itself has a parent!`);else{const e=n.get(t.parent);e?e.children.push(i):console.error(`Node #${t.index} has #${t.parent} as a parent, which is not yet defined!`)}}));const i=n.get(e.index);if(!i)throw Error("Impossible error! There must be a bug in CellNodes.buildTree().");return i}}function M(t,e,n){if(t.parent<0)return 0;if(n.has(t.index))return n.get(t.index);const i=e.get(t.parent);if(!i)return 0;const s=i.x-t.x,r=i.y-t.y,a=i.z-t.z,o=Math.sqrt(s*s+r*r+a*a)+M(i,e,n);return n.set(t.index,o),o}class T{constructor(t,e=0){this.onChange=t,this._value=0,this._value=e}set(t){this._value!==t&&(this._value=t,this.onChange(this))}get(){return this._value}}class R{constructor(t,e=0,n=0){this.onChange=t,this._width=0,this._height=0,this._width=e,this._height=n}get width(){return this._width}set width(t){t!==this._width&&(this._width=t,this.onChange(this))}get height(){return this._height}set height(t){t!==this._height&&(this._height=t,this.onChange(this))}}class D{constructor(t,e=0,n=0,i=0){this.onChange=t,this._x=0,this._y=0,this._z=0,this._x=e,this._y=n,this._z=i}set([t,e,n]){this._x=t,this._y=e,this._z=n,this.onChange(this)}setYZX([t,e,n]){this._x=e,this._y=n,this._z=t,this.onChange(this)}asArray(){return[this._x,this._y,this._z]}asVec3(){return w(this._x,this._y,this._z)}get x(){return this._x}set x(t){t!==this._x&&(this._x=t,this.onChange(this))}get y(){return this._y}set y(t){t!==this._y&&(this._y=t,this.onChange(this))}get z(){return this._z}set z(t){t!==this._z&&(this._z=t,this.onChange(this))}}function C(){var t=new g(16);return g!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function P(){var t=new g(9);return g!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function U(){var t=new g(4);return g!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}_=new g(4),g!=Float32Array&&(_[0]=0,_[1]=0,_[2]=0,_[3]=0);y(),w(1,0,0),w(0,1,0),U(),U(),P(),w(1,0,0),w(0,1,0),w(0,0,1);class z{constructor(){this.dirty=!0,this.matrixView=C(),this.matrixProjection=C(),this.orientation=U(),this.axis=P(),this.axisX=y(),this.axisY=y(),this.axisZ=y(),this.position=y(),this.listeners=new Set,this.handleDirty=()=>{this.dirty=!0,this.listeners.forEach((t=>{t()}))},this.zoom=new T(this.handleDirty,1),this.target=new D(this.handleDirty,0,0,0),this.viewport=new R(this.handleDirty,1,1),this.near=new T(this.handleDirty,.001),this.far=new T(this.handleDirty,1e6),this.facePosZ()}addEventListener(t,e){this.listeners.add(e)}removeEventListener(t,e){this.listeners.delete(e)}setUniforms(t,e,n){const{matrixView:i,matrixProjection:s}=this;this.updateIfDirty(),t.uniformMatrix4fv(e,!1,i),t.uniformMatrix4fv(n,!1,s)}facePosZ(){var t;(t=this.orientation)[0]=0,t[1]=0,t[2]=0,t[3]=1,this.handleDirty()}rotateAroundXY(t,e){this.updateIfDirty();const{axisX:n,axisY:i,axisZ:s}=this;S(i,n,t),S(s,n,t),S(n,i,e),S(s,i,e),this.axis[0]=n[0],this.axis[1]=n[1],this.axis[2]=n[2],this.axis[3]=i[0],this.axis[4]=i[1],this.axis[5]=i[2],this.axis[6]=s[0],this.axis[7]=s[1],this.axis[8]=s[2],function(t,e){var n,i=e[0]+e[4]+e[8];if(i>0)n=Math.sqrt(i+1),t[3]=.5*n,n=.5/n,t[0]=(e[5]-e[7])*n,t[1]=(e[6]-e[2])*n,t[2]=(e[1]-e[3])*n;else{var s=0;e[4]>e[0]&&(s=1),e[8]>e[3*s+s]&&(s=2);var r=(s+1)%3,a=(s+2)%3;n=Math.sqrt(e[3*s+s]-e[3*r+r]-e[3*a+a]+1),t[s]=.5*n,n=.5/n,t[3]=(e[3*r+a]-e[3*a+r])*n,t[r]=(e[3*r+s]+e[3*s+r])*n,t[a]=(e[3*a+s]+e[3*s+a])*n}}(this.orientation,this.axis),function(t,e){var n=e[0],i=e[1],s=e[2],r=e[3],a=n*n+i*i+s*s+r*r;a>0&&(a=1/Math.sqrt(a)),t[0]=n*a,t[1]=i*a,t[2]=s*a,t[3]=r*a}(this.orientation,this.orientation),this.handleDirty()}updateIfDirty(){this.dirty&&(this.dirty=!1,this.updateView(),this.updateProjection())}}function S(t,e,n){const[i,s,r]=e,a=Math.cos(n),o=Math.sin(n);var h,c,u,l,f,d,v,m,p,y;A(t,t,(h=a+(1-a)*i*i,c=(1-a)*i*s+o*r,u=(1-a)*i*r-o*s,l=(1-a)*i*s-o*r,f=a+(1-a)*s*s,d=(1-a)*s*r+o*i,v=(1-a)*i*r+o*s,m=(1-a)*s*r-o*i,p=a+(1-a)*r*r,(y=new g(9))[0]=h,y[1]=c,y[2]=u,y[3]=l,y[4]=f,y[5]=d,y[6]=v,y[7]=m,y[8]=p,y))}w(1,0,0),w(0,1,0),w(0,0,1);const F=w(1,0,0),I=w(0,1,0),L=w(0,0,1);class O extends z{constructor(){super(),this.height=new T(this.handleDirty)}updateProjection(){const t=this.viewport.width/this.viewport.height,e=this.zoom.get()*this.height.get(),n=t*e,i=this.near.get(),s=this.far.get();var r,a,o,h,c;a=2/n,o=2/e,h=-2/(s-i),c=-2/(s+i),(r=this.matrixProjection)[0]=a,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=o,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=h,r[11]=0,r[12]=0,r[13]=0,r[14]=c,r[15]=1}updateView(){const t=this.near.get(),e=this.far.get(),n=Math.abs(e-t);var i,s,r,a,o,h,c,u,l,f,d,v,m,g,y,x,w,b;i=this.axis,f=(r=(s=this.orientation)[0])*(c=r+r),d=(a=s[1])*c,v=a*(u=a+a),m=(o=s[2])*c,g=o*u,y=o*(l=o+o),x=(h=s[3])*c,w=h*u,b=h*l,i[0]=1-v-y,i[3]=d-b,i[6]=m+w,i[1]=d+b,i[4]=1-f-y,i[7]=g-x,i[2]=m-w,i[5]=g+x,i[8]=1-f-v,A(this.axisX,F,this.axis),A(this.axisY,I,this.axis),A(this.axisZ,L,this.axis),function(t,e,n,i){t[0]=e[0]+n[0]*i,t[1]=e[1]+n[1]*i,t[2]=e[2]+n[2]*i}(this.position,this.target.asVec3(),this.axisZ,.25*n+t),function(t,e,n,i){var s,r,a,o,h,c,u,l,f,d,v=e[0],m=e[1],g=e[2],y=i[0],x=i[1],w=i[2],b=n[0],E=n[1],A=n[2];Math.abs(v-b)<p&&Math.abs(m-E)<p&&Math.abs(g-A)<p?function(t){t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1}(t):(u=v-b,l=m-E,f=g-A,s=x*(f*=d=1/Math.hypot(u,l,f))-w*(l*=d),r=w*(u*=d)-y*f,a=y*l-x*u,(d=Math.hypot(s,r,a))?(s*=d=1/d,r*=d,a*=d):(s=0,r=0,a=0),o=l*a-f*r,h=f*s-u*a,c=u*r-l*s,(d=Math.hypot(o,h,c))?(o*=d=1/d,h*=d,c*=d):(o=0,h=0,c=0),t[0]=s,t[1]=o,t[2]=u,t[3]=0,t[4]=r,t[5]=h,t[6]=l,t[7]=0,t[8]=a,t[9]=c,t[10]=f,t[11]=0,t[12]=-(s*v+r*m+a*g),t[13]=-(o*v+h*m+c*g),t[14]=-(u*v+l*m+f*g),t[15]=1)}(this.matrixView,this.position,this.target.asArray(),this.axisY),console.log("🚀 [camera-orthographic] this.position = ",this.position),console.log("🚀 [camera-orthographic] this.target.asArray() = ",this.target.asArray())}}class Y{constructor(t){this.options=t,this.start={x:0,y:0,t:0},this.current={x:0,y:0,t:0},this.previous={x:0,y:0,t:0},this.canvas=null,this.active=!1,this.canvasX=0,this.canvasY=0,this.screenX=0,this.screenY=0,this.handleCanvasWheel=t=>{const{onZoom:e}=this.options;e&&(t.preventDefault(),e(t.deltaY))},this.handleCanvasPointerDown=t=>{this.canvasX=t.clientX,this.canvasY=t.clientY,this.active=!0},this.handlePointerDown=t=>{var e,n;if(!this.active)return;this.screenX=t.clientX,this.screenY=t.clientY;const i=this.getPoint(t);this.start=this.current=i,null===(n=(e=this.options).onMoveStart)||void 0===n||n.call(e,i)},this.handlePointerMove=t=>{var e,n;this.active&&this.canvas&&(this.previous=this.current,this.current=this.getPoint(t),null===(n=(e=this.options).onMove)||void 0===n||n.call(e,this))},this.handlePointerUp=t=>{var e,n;this.active&&(null===(n=(e=this.options).onMoveEnd)||void 0===n||n.call(e,this.getPoint(t)),this.active=!1)},t.canvas&&this.attach(t.canvas)}attach(t){this.detach(),this.canvas=t,t.addEventListener("pointerdown",this.handleCanvasPointerDown,!0),t.addEventListener("wheel",this.handleCanvasWheel),document.addEventListener("pointerdown",this.handlePointerDown),document.addEventListener("pointermove",this.handlePointerMove),document.addEventListener("pointerup",this.handlePointerUp)}detach(){const{canvas:t}=this;t&&(t.removeEventListener("pointerdown",this.handleCanvasPointerDown),t.removeEventListener("wheel",this.handleCanvasWheel),document.removeEventListener("pointerdown",this.handlePointerDown),document.removeEventListener("pointermove",this.handlePointerMove),document.removeEventListener("pointerup",this.handlePointerUp),this.canvas=null)}getPoint(t){if(!this.canvas)throw Error("No canvas has been defined!");const{left:e,top:n,width:i,height:s}=this.canvas.getBoundingClientRect();return{x:2*((this.canvasX+t.clientX-this.screenX-e)/i-.5),y:-2*((this.canvasY+t.clientY-this.screenY-n)/s-.5),t:t.timeStamp}}}class V{constructor(t,e={}){this.camera=t,this.options=e,this.handleZoom=t=>{const e=t>0?1.1:.9,n=this.camera.zoom.get();this.camera.zoom.set(n*e)},this.handleStart=()=>{},this.handleMove=({previous:t,current:e})=>{const n=e.x-t.x,i=5*(e.y-t.y),s=5*-n;this.camera.rotateAroundXY(i,s)},this.gestures=new Y({onMoveStart:this.handleStart,onMove:this.handleMove,onZoom:this.handleZoom})}attach(t){this.gestures.attach(t);const{onChange:e}=this.options;e&&this.camera.addEventListener("change",e)}detach(){this.gestures.detach();const{onChange:t}=this.options;t&&this.camera.removeEventListener("change",t)}}function X(t,e,n){var i;const s=t.createShader("vertex"===e?t.VERTEX_SHADER:t.FRAGMENT_SHADER);if(!s)throw Error("Unable to create a Vertex Shader handle!");t.shaderSource(s,n),t.compileShader(s);const r=null!==(i=t.getShaderInfoLog(s))&&void 0!==i?i:"";if(r.length>0){console.error("Shader error!",r);const t=k(r);throw W(`${e.toUpperCase()} Shader`,n,...t),Error(`Error in ${e.toUpperCase()} shader: ${r}`)}return s}const N=/^ERROR:[ \t]+([0-9]+):([0-9]+):/g;function k(t){const e=[];for(const n of t.split("\n")){N.lastIndex=-1;const t=N.exec(n);t&&e.push(parseInt(t[2],10))}return e}function $(t,e=!1){return`color:#fff;background:${t};font-family:monospace;font-size:80%;font-weight:${e?"bolder":"100"}`}function W(t,e,...n){console.log(`%c${t}`,"font-weight:bolder;font-size:120%"),e.split("\n").forEach(((t,e)=>{const i=e+1,s=(1e-4*i).toFixed(4).substring(2),r=n.includes(i)?"#f00":"#000";console.log(`%c${s}  %c${t}`,$(r),$(r,!0))}))}class Z{constructor(t){this.gl=t,this.programs=new Set,this.buffers=new Set}cleanUp(){const{gl:t}=this;this.programs.forEach((({prg:e,shaders:n})=>{n.forEach((e=>t.deleteShader(e))),t.deleteProgram(e)})),this.buffers.forEach((e=>t.deleteBuffer(e)))}createProgram(t){const{prg:e,shaders:n}=function(t,e){var n;const i=t.createProgram();if(!i)throw Error("Unable to create a WebGL program!");const s=X(t,"vertex",e.vert);t.attachShader(i,s);const r=X(t,"fragment",e.frag);if(t.attachShader(i,r),t.linkProgram(i),!t.getProgramParameter(i,t.LINK_STATUS)){const s=null!==(n=t.getProgramInfoLog(i))&&void 0!==n?n:"";console.warn(s);const r=k(s);throw W("Vertex Shader",e.vert,...r),W("Fragment Shader",e.frag,...r),new Error("Could NOT link WebGL2 program!\n"+s)}return{prg:i,shaders:[s,r]}}(this.gl,t);return this.programs.add({prg:e,shaders:n}),e}createBuffer(){const t=this.gl.createBuffer();if(!t)throw Error("Unable to create a WebGLBuffer!");return this.buffers.add(t),t}createVAO(t,...e){const{gl:n}=this,i=n.createVertexArray();if(!i)throw Error("Unable to create VertexArrayObject!");n.bindVertexArray(i);let s=!1;for(const i of e)if("function"==typeof i)i(this);else if(i instanceof Uint8Array||i instanceof Uint16Array||i instanceof Uint32Array){if(s)throw Error("createVAO() can have only one UintArray in the arguments!");s=!0;const t=this.createBuffer();n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t),n.bufferData(n.ELEMENT_ARRAY_BUFFER,i,n.STATIC_DRAW)}else i.buffer||(i.buffer=this.createBuffer()),i.update(n),n.bindBuffer(n.ARRAY_BUFFER,i.buffer),i.define(n,t);return n.bindVertexArray(null),i}getUniformsLocations(t){const{gl:e}=this,n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);if("number"!=typeof n)throw Error("Unable to get the number of uniforms in a WebGLProgram!");const i={};for(let s=0;s<n;s++){const n=e.getActiveUniform(t,s);if(!n)continue;const r=e.getUniformLocation(t,n.name);if(null===r)throw Error(`Unable to get location for uniform "${n.name}"!`);i[n.name]=r}return i}}class j{constructor(){this._swc=null,this._canvas=null,this.nodes=null,this.paintingIsScheduled=!1,this.painter=null,this.grid=null,this._colorBy="section",this._radiusType=0,this._radiusMultiplier=1,this.resetCamera=()=>{const t=this._camera;t.facePosZ();const{nodes:e}=this;if(e){const[n,i]=e.bbox,s=2*Math.abs(n),r=2*Math.abs(i),a=s/r,o=t.viewport.width/t.viewport.height,h=o>a?r:r*a/o;t.height.set(1.05*h),t.zoom.set(1)}},this.paint=()=>{this.paintingIsScheduled||window.requestAnimationFrame(this.actualPaint)},this.actualPaint=t=>{var e,n;this.paintingIsScheduled=!1,null===(e=this.grid)||void 0===e||e.paint(),null===(n=this.painter)||void 0===n||n.paint(t)},this.handleColorsChange=()=>{var t;null===(t=this.painter)||void 0===t||t.resetColors(this.colors)},this._camera=new O,this.orbiter=new V(this._camera,{onChange:this.paint}),this.colors=new n(this.handleColorsChange)}get colorBy(){var t,e;return null!==(e=null===(t=this.painter)||void 0===t?void 0:t.colorBy)&&void 0!==e?e:this._colorBy}set colorBy(t){const{painter:e}=this;this._colorBy=t,e&&(e.colorBy=t)}get radiusType(){var t,e;return null!==(e=null===(t=this.painter)||void 0===t?void 0:t.radiusType)&&void 0!==e?e:this._radiusType}set radiusType(t){const{painter:e}=this;this._radiusType=t,e&&(e.radiusType=t)}get radiusMultiplier(){var t,e;return null!==(e=null===(t=this.painter)||void 0===t?void 0:t.radiusMultiplier)&&void 0!==e?e:this._radiusMultiplier}set radiusMultiplier(t){const{painter:e}=this;this._radiusMultiplier=t,e&&(e.radiusMultiplier=t)}get canvas(){return this._canvas}set canvas(t){t!==this._canvas&&(this._camera.removeEventListener("change",this.paint),this.orbiter.detach(),t&&(this.orbiter.attach(t),this._camera.addEventListener("change",this.paint)),this._canvas=t,this.init())}get swc(){return this._swc}set swc(t){if(t!==this._swc&&(this._swc=t,this.nodes=null,t)){const e=new B(function(t){const e=[];for(const n of i(t)){const t=l(n).split(/\s+/);if(t.length<7)continue;const[i,s,r,a,h,c,u]=t.map((t=>Number(t))),d=s>0&&s<5?s:o.Unknown;e.push({index:i,parent:u,type:d,x:r,y:a,z:h,radius:c,u:0,v:f(d)})}return e}(t));e.computeDistancesFromSoma(),this.nodes=e,this.init()}}init(){const{canvas:t,nodes:e}=this;if(!t||!e)return;this.painter&&this.painter.cleanUp();const n=this._camera,[i,s,r]=e.center,[a,o,h]=e.bbox;n.near.set(1e-6),n.far.set(1e3*Math.max(a,o,h)),n.target.set([i,s,r]),n.height.set(h+Math.max(a,o)),window.requestAnimationFrame(this.resetCamera);const c=t.getContext("webgl2");if(!c)throw Error("Unable to create WebGL2 context!");const u=new Z(c);this.painter=new m(u,e,n),this.colors&&this.painter.resetColors(this.colors)}}var G=e.$;export{G as MorphologyPainter};