var t={d:(e,i)=>{for(var n in i)t.o(i,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:i[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{$:()=>H});class i{constructor(t){this.onChange=t,this._soma="#444",this._axon="#00f",this._apicalDendrite="#f0f",this._basalDendrite="#f00",this._unknown="#888"}get soma(){return this._soma}set soma(t){t!==this._soma&&(this._soma=t,this.fire())}get axon(){return this._axon}set axon(t){t!==this._axon&&(this._axon=t,this.fire())}get apicalDendrite(){return this._apicalDendrite}set apicalDendrite(t){t!==this._apicalDendrite&&(this._apicalDendrite=t,this.fire())}get basalDendrite(){return this._basalDendrite}set basalDendrite(t){t!==this._basalDendrite&&(this._basalDendrite=t,this.fire())}get unknown(){return this._unknown}set unknown(t){t!==this._unknown&&(this._unknown=t,this.fire())}fire(){this.onChange(this)}}const n=function*(t){const e=t.length;let i=0,n=0;for(;i>-1&&i<e&&(i=t.indexOf("\n",n),!(i<0));)yield t.substring(n,i).trim(),n=i+1;return t.substring(n).trim()};function s(t){return 3===t.length}function r(t,e){const i=[];if(e)for(let n=0;n<t;n++)i.push(e(n));else for(let e=0;e<t;e++)i.push(e);return i}var a,o;!function(t){t[t.X=0]="X",t[t.Y=1]="Y",t[t.Z=2]="Z",t[t.W=3]="W"}(a||(a={}));class h{constructor(t,e=0){this.divisor=e,this.buffer=null,this.arrayBuffer=null,this.data={},this.verticeCount=0;let i=0;const n={},s={};for(const r of Object.keys(t)){n[r]=new ArrayBuffer(0);const a=c(t[r],e,i);s[r]=a,i+=a.bytesPerElement*a.dimension}this.data=n,this.definitions=s,this.stride=i}getVerticeCount(){return this.verticeCount}debug(){const{definitions:t,verticeCount:e}=this;console.log("Vertices count:",e);const i=new Float32Array(this.get());console.log(i);for(const i of Object.keys(t)){const n=t[i];console.log(i,r(e).map((t=>r(n.dimension).map((e=>this.peek(i,t,e))))))}}getNames(){return Object.keys(this.definitions)}getDefinitions(){return structuredClone(this.definitions)}getAttribDef(t){const e=this.definitions[t];return e?structuredClone(e):void 0}getGlslType(t){const e=this.definitions[t];if(!e)return`/* "${t}" not found! */`;switch(e.dimension){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:return`/* Don't know how to deal with dimension ${e.dimension}! */`}}get(t=0){const e=t>0?t:this.verticeCount,i=this.stride*e;if(!this.arrayBuffer||this.arrayBuffer.byteLength<i){this.checkIfWeHaveEnoughData(e),this.arrayBuffer=new ArrayBuffer(i);const t=new DataView(this.arrayBuffer);let n=0;const{data:s,definitions:r}=this;for(let i=0;i<e;i++)for(const e of Object.keys(r)){const a=r[e],o=s[e],h=new DataView(o);let c=a.bytesPerElement*a.dimension*i;for(let e=0;e<a.dimension;e++)a.setter(t,n,a.getter(h,c)),c+=a.bytesPerElement,n+=a.bytesPerElement}}return this.arrayBuffer}update(t,e=0,i=!1){const n=this.getBuffer(),s=e>0?e:this.verticeCount,r=this.get(s);return t.bindBuffer(t.ARRAY_BUFFER,n),t.bufferData(t.ARRAY_BUFFER,r,i?t.DYNAMIC_DRAW:t.STATIC_DRAW),r}define(t,e){const{buffer:i}=this;i&&t.bindBuffer(t.ARRAY_BUFFER,i);let n=0;const{definitions:s}=this;for(const i of Object.keys(s)){const r=s[i],a=t.getAttribLocation(e,i);if(a<0)throw Error(u(i));t.enableVertexAttribArray(a),t.vertexAttribPointer(a,r.dimension,t.FLOAT,!1,this.stride,n),t.vertexAttribDivisor(a,r.divisor),n+=r.dimension*r.bytesPerElement}}set(t,e){var i;(i=e)&&"object"==typeof i&&e.buffer instanceof ArrayBuffer&&(e=e.buffer),this.data[t]=e;const{bytesPerElement:n,dimension:s}=this.definitions[t];this.verticeCount=Math.max(this.verticeCount,Math.ceil(e.byteLength/(n*s))),this.arrayBuffer=null}poke(t,e,i,n){if(e>=this.verticeCount)return;const s=this.get(this.verticeCount),r=new DataView(s),{setter:a,bytesPerElement:o,bytesOffset:h}=this.definitions[t];a(r,h+e*this.stride+o*i,n)}peek(t,e,i){if(e>=this.verticeCount)return 0;const n=this.get(this.verticeCount),s=new DataView(n),{getter:r,bytesPerElement:a,bytesOffset:o}=this.definitions[t];return r(s,o+e*this.stride+a*i)}getBuffer(){const{buffer:t}=this;if(!t)throw Error(`Wgl2Attribute.buffer has not been set!\n${JSON.stringify(this.definitions,null,"  ")}`);return t}checkIfWeHaveEnoughData(t){const{data:e,definitions:i}=this;for(const n of Object.keys(i)){const s=e[n];if(!s)throw Error(`No data has been set for attribute "${n}"!\nPlease use something like this:\n    data.set("${n}", new Float32Array([4, 3]))`);const r=i[n],a=r.bytesPerElement*r.dimension*t;if(s.byteLength<a)throw Error(`Attribute "${n}" has only ${s.byteLength} bytes, but we need at least ${a} since you asked for ${t} vertices!`)}}}function c(t,e,i){const n="number"==typeof t?{dimension:t,type:"float"}:Object.assign({type:"float",dimension:1},t);if("float"===n.type)return function(t,e,i){const n=Float32Array.BYTES_PER_ELEMENT;return{dimension:t.dimension,divisor:e,bytesPerElement:n,bytesOffset:i,getter:(t,e)=>t.getFloat32(e,!0),setter(t,e,i){t.setFloat32(e,i,!0)}}}(n,e,i);throw Error(`Unable to create a Data for an attribute of type "${n.type}"!`)}function u(t){return`Unable to find atribute "${t}"!`}function l(t){const e=t.indexOf("#");return e<0?t:t.substring(0,e).trim()}function f(t){return(function(t){switch(t){case o.Soma:return 0;case o.Axon:return 1;case o.ApicalDendrite:return 2;case o.BasalDendrite:return 3;default:return 4}}(t)+.5)/5}!function(t){t[t.Soma=1]="Soma",t[t.Axon=2]="Axon",t[t.BasalDendrite=3]="BasalDendrite",t[t.ApicalDendrite=4]="ApicalDendrite",t[t.Unknown=666]="Unknown"}(o||(o={}));class d{constructor(t){this.nodes=t,this._count=0,this.nodesXYZR=[],this.nodesUV=[],this.nodesInfluence=[],this.attAxyzr=[],this.attBxyzr=[],this.attAuv=[],this.attBuv=[],this.attAinfluence=[],this.attBinfluence=[],this.elemByIndex=new Map,t.forEach((({index:t,type:e,x:i,y:n,z:s,radius:r,u:a,v:h})=>{const c=this.nodesUV.length;this.nodesXYZR.push([i,n,s,r]),this.nodesUV.push([a,h]),this.nodesInfluence.push(e===o.Soma?0:1),this.elemByIndex.set(t,c)}))}get count(){return this._count}addSegment(t,e){const i=this.elemByIndex.get(t);if("number"!=typeof i)return;const n=this.elemByIndex.get(e);if("number"!=typeof n)return;const s=this.nodesXYZR[i],r=this.nodesXYZR[n];this.attAxyzr.push(...s),this.attBxyzr.push(...r);const a=this.nodesUV[i],o=this.nodesUV[n];this.attAuv.push(...a),this.attBuv.push(...o),this.attAinfluence.push(this.nodesInfluence[i]),this.attBinfluence.push(this.nodesInfluence[n]),this._count++}makeAttributes(t=1){const e=new h({attAxyzr:4,attBxyzr:4,attAuv:2,attBuv:2,attAinfluence:1,attBinfluence:1},t);return e.set("attAxyzr",new Float32Array(this.attAxyzr)),e.set("attBxyzr",new Float32Array(this.attBxyzr)),e.set("attAuv",new Float32Array(this.attAuv)),e.set("attBuv",new Float32Array(this.attBuv)),e.set("attAinfluence",new Float32Array(this.attAinfluence)),e.set("attBinfluence",new Float32Array(this.attBinfluence)),e}}function v(t,e){const i=document.createElement("canvas");if(!i)throw Error("Unable to create a HTMLCanvasElement!");i.width=t,i.height=e;const n=i.getContext("2d");if(!n)throw Error("Unable to create a 2D context!");return n}class m{constructor(t,e,i){this.resources=t,this.camera=i,this.gl=null,this.prg=null,this.vao=null,this.texture=null,this.locations={},this.instancesCount=0,this._radiusMultiplier=1,this._radiusType=0,this._colorBy="section",this.textureIsOutOfDate=!0,this.paint=t=>{const e=1-this._radiusType,i=this._radiusType,{gl:n,camera:s,locations:r,textureIsOutOfDate:a,texture:o,colorBy:h}=this;n&&(s.viewport.width=n.drawingBufferWidth,s.viewport.height=n.drawingBufferHeight,n.useProgram(this.prg),o&&a&&(n.bindTexture(n.TEXTURE_2D,o),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,"section"===h?function({soma:t="#444",axon:e="#00f",apicalDendrite:i="#f0f",basalDendrite:n="#f00",unknown:s="#888"}={}){const r=v(1,5);return[t,e,n,i,s].forEach(((t,e)=>{r.fillStyle=t;const i=e;r.fillRect(0,i,1,i+1)})),r.canvas}(this.colors):function(){const t=v(256,1),e=["#0f0","#ff0","#f00"],i=t.createLinearGradient(0,0,256,1);return e.forEach(((t,n)=>{i.addColorStop(n/(e.length-1),t)})),t.fillStyle=i,t.fillRect(0,0,256,1),t.canvas}()),this.textureIsOutOfDate=!1),s.setUniforms(n,r.uniModelViewMatrix,r.uniProjectionMatrix),n.uniform1f(r.uniAspect,n.drawingBufferWidth/n.drawingBufferHeight),n.enable(n.DEPTH_TEST),n.clearDepth(1),n.depthFunc(n.LESS),n.depthMask(!0),n.depthRange(0,1),n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),n.bindVertexArray(this.vao),n.uniform1f(r.uniRadiusMultiplier,this._radiusMultiplier*e),n.uniform1f(r.uniRadiusAdditioner,this.averageRadius*this._radiusMultiplier*i),n.uniform1f(r.uniLightness,1),n.uniform1f(r.uniZFight,0),n.uniform1f(r.uniOutline,1),n.drawElementsInstanced(n.TRIANGLES,48,n.UNSIGNED_BYTE,0,this.instancesCount),n.uniform1f(r.uniOutline,1.2),n.uniform1f(r.uniLightness,0),n.uniform1f(r.uniZFight,1),n.drawElementsInstanced(n.TRIANGLES,48,n.UNSIGNED_BYTE,0,this.instancesCount))},this.handleResize=()=>{const{canvas:t,gl:e}=this,i=t.clientWidth,n=t.clientHeight;t.width=i,t.height=n,null==e||e.viewport(0,0,i,n),this.refresh()};const{gl:r}=t;this.gl=r,this.observer=new ResizeObserver(this.handleResize);const a=r.canvas;if(!(a instanceof HTMLCanvasElement))throw Error("This painter works only with a real HTMLCanvasElement!");this.canvas=a,this.observer.observe(a),this.resources=t,this.averageRadius=e.averageRadius;const o=t.createProgram({vert:"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uniTexture;\nuniform mat4 uniModelViewMatrix;\nuniform mat4 uniProjectionMatrix;\nuniform float uniAspect;\nuniform float uniRadiusMultiplier;\nuniform float uniRadiusAdditioner;\nuniform float uniOutline;\nuniform float uniLightness;\nuniform float uniZFight;\n/**\n * Positoon of center A, plus radius.\n */\nin vec4 attAxyzr;\n/**\n * Positoon of center B, plus radius.\n */\nin vec4 attBxyzr;\nin vec2 attAuv;\nin vec2 attBuv;\nin float attAinfluence;\nin float attBinfluence;\n/**\n * 0.0: we are using center A.\n * 1.0: we are using center B.\n */\nin float attCenter;\n/**\n * Position of the point relative to the current center.\n */\nin vec2 attOffset;\nout vec3 varColor;\n\nconst float EPSILON = 1e-5;\n\nfloat scaleRadius(float radius, float influence) {\n    float multiplier = mix(1.0, uniRadiusMultiplier, influence);\n    float additioner = uniRadiusAdditioner * influence;\n    return (radius * multiplier + additioner) * mix(1.0, uniOutline, influence);\n}\n\nvec3 safeNormalize(vec3 v) {\n    float len2 = dot(v, v);\n    if (len2 < 1e-6) return vec3(0, 1, 0);\n\n    return inversesqrt(len2) * v;\n}\n\nvoid main() {\n    vec2 uv = attCenter == 0.0 ? attAuv : attBuv;\n    varColor = texture(uniTexture, uv).rgb * uniLightness;\n\n    vec3 vecRadius = vec3(\n        0.0,\n        attCenter == 0.0 \n            ? scaleRadius(attAxyzr.w, attAinfluence) \n            : scaleRadius(attBxyzr.w, attBinfluence), \n        0.0\n    );\n    vec4 cameraA = uniModelViewMatrix * vec4(attAxyzr.xyz, 1.0);\n    vec4 cameraB = uniModelViewMatrix * vec4(attBxyzr.xyz, 1.0);\n    vec4 cameraC = attCenter == 0.0 ? cameraA : cameraB;\n    vec3 cameraAxisY = (cameraB - cameraA).xyz;\n    cameraAxisY.z = 0.0;\n    cameraAxisY = safeNormalize(cameraAxisY);\n    vec3 cameraAxisX = vec3(\n        -cameraAxisY.y,\n        cameraAxisY.x,\n        cameraAxisY.z\n    );\n    float radius = attCenter == 0.0 \n            ? scaleRadius(attAxyzr.w, attAinfluence) \n            : scaleRadius(attBxyzr.w, attBinfluence);\n    vec3 cameraPoint = cameraC.xyz + radius * (\n        attOffset.x * cameraAxisX\n        + attOffset.y * cameraAxisY\n    );\n    vec4 screenPoint = uniProjectionMatrix * vec4(cameraPoint, 1.0);\n    screenPoint.z += uniZFight * EPSILON;\n    gl_Position = screenPoint;\n}\n",frag:"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uniTexture;\n\nin vec3 varColor;\nout vec4 FragColor;\n\n\nvoid main() {\n    FragColor = vec4(varColor, 1.0);\n}\n"});this.prg=o,this.locations=t.getUniformsLocations(o);const{attributes:c,elements:u}=function(){const{vertices:t,faces:e}=function(t){const e=[],i=[];for(const t of n("# Blender 4.0.1\n# www.blender.org\no Circle\nv 0.000000 2.000000 0.000000\nv -0.500000 1.866025 0.000000\nv -0.866025 1.500000 0.000000\nv -1.000000 1.000000 0.000000\nv -0.500000 -1.933013 0.000000\nv -0.866025 -1.566987 0.000000\nv -1.000000 -1.066987 0.000000\nv 1.000000 -1.066987 0.000000\nv 0.866025 -1.566987 0.000000\nv 1.000000 1.000000 0.000000\nv 0.866025 1.500000 0.000000\nv 0.500000 1.866025 0.000000\nv 0.500000 -1.933013 0.000000\nv -0.000000 -2.066987 0.000000\nv 0.000000 1.000000 0.000000\nv 0.000000 -1.066987 0.000000\ns 0\nf 3 15 4\nf 2 15 3\nf 1 15 2\nf 12 15 1\nf 11 15 12\nf 10 15 11\nf 9 16 8\nf 13 16 9\nf 14 16 13\nf 5 16 14\nf 6 16 5\nf 7 16 6\nf 4 16 7\nf 4 15 16\nf 16 15 8\nf 15 10 8\n")){if(t.startsWith("v ")){const i=t.substring(2).split(" ").map((t=>Number(t)));s(i)&&e.push(i)}if(t.startsWith("f ")){const e=t.substring(2).split(" ").map((t=>Number(t)-1));if(!s(e))throw Error(`This simple Wavefront parser accepts only triangles!\n${t}`);i.push(...e)}}return{vertices:e,faces:i}}(),i=new h({attCenter:1,attOffset:2}),r=[],a=[];for(const[e,i]of t){const t=i>0;r.push(t?1:0),a.push(e,i-(t?1:-1))}return i.set("attCenter",new Float32Array(r)),i.set("attOffset",new Float32Array(a)),{attributes:i,elements:new Uint8Array(e)}}(),l=new d(e);e.forEach((({index:t,parent:e,type:i,radius:n,x:s,y:r,z:a})=>{e<0||l.addSegment(t,e)})),this.instancesCount=l.count;const f=l.makeAttributes();this.vao=t.createVAO(o,c,f,new Uint8Array(u)),r.clearColor(1,1,1,1),this.texture=function(t){const e=t.createTexture();if(!e)throw Error("Unable to create a WebGLTexture!");return t.activeTexture(t.TEXTURE0+0),t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),e}(r)}get colorBy(){return this._colorBy}set colorBy(t){t!==this._colorBy&&(this._colorBy=t,this.textureIsOutOfDate=!0,this.refresh())}get radiusType(){return this._radiusType}set radiusType(t){t!==this._radiusType&&(this._radiusType=t,this.refresh())}get radiusMultiplier(){return this._radiusMultiplier}set radiusMultiplier(t){this._radiusMultiplier!==t&&(this._radiusMultiplier=t,this.refresh())}cleanUp(){this.resources.cleanUp(),this.observer.unobserve(this.canvas)}resetColors(t){this.textureIsOutOfDate=!0,this.colors=t}refresh(){window.requestAnimationFrame(this.paint)}}var p=1e-6,g="undefined"!=typeof Float32Array?Float32Array:Array;function y(){var t=new g(3);return g!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function x(t){var e=new g(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function w(t,e,i){var n=new g(3);return n[0]=t,n[1]=e,n[2]=i,n}function b(t,e,i){return t[0]=e[0]+i[0],t[1]=e[1]+i[1],t[2]=e[2]+i[2],t}function _(t,e,i){return t[0]=e[0]-i[0],t[1]=e[1]-i[1],t[2]=e[2]-i[2],t}function E(t,e,i){var n=e[0],s=e[1],r=e[2];return t[0]=n*i[0]+s*i[3]+r*i[6],t[1]=n*i[1]+s*i[4]+r*i[7],t[2]=n*i[2]+s*i[5]+r*i[8],t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var A;y();class M{constructor(t){this.nodes=t,this.nodesByIndex=new Map;let e=0,i=0;t.forEach((t=>{t.type!==o.Soma&&(e+=t.radius,i++),this.nodesByIndex.set(t.index,t)})),this.averageRadius=0===i?0:e/i,t.forEach((t=>{0===t.radius&&(t.radius=this.averageRadius)}));const{center:n,bbox:s}=function(t){const[e]=t;if(!e)throw Error("Unable to compute bounding box because the nodes array is empty!");const i=w(e.x,e.y,e.z),n=x(i),s=x(i),r=x(i);let a=1;for(const{x:u,y:l,z:f,radius:d,index:v,type:m,parent:p}of t){if(v===e.index)continue;const t=w(u,l,f);-1===p&&(c=t,(h=i)[0]=c[0],h[1]=c[1],h[2]=c[2]),m===o.Soma&&(b(r,r,t),a++),n[0]=Math.min(n[0],t[0]-d),s[0]=Math.max(s[0],t[0]+d),n[1]=Math.min(n[1],t[1]-d),s[1]=Math.max(s[1],t[1]+d),n[2]=Math.min(n[2],t[2]-d),s[2]=Math.max(s[2],t[2]+d)}var h,c;return function(t,e,i){t[0]=e[0]*i,t[1]=e[1]*i,t[2]=e[2]*i}(r,r,1/a),_(n,n,r),_(s,s,r),{center:[...r],bbox:[Math.max(Math.abs(n[0]),Math.abs(s[0])),Math.max(Math.abs(n[1]),Math.abs(s[1])),Math.max(Math.abs(n[2]),Math.abs(s[2]))]}}(t);this.center=n,this.bbox=s,this.tree=this.buildTree()}getByIndex(t){return this.nodesByIndex.get(t)}forEach(t){this.nodes.forEach(t)}computeDistancesFromSoma(){const{nodes:t}=this,e=new Map,i=new Map;t.forEach((t=>e.set(t.index,t)));let n=0;if(t.forEach((t=>{const s=B(t,e,i);t.u=s,n=Math.max(n,s)})),0===n)return;const s=1/n;t.forEach((t=>t.u*=s))}buildTree(){const{nodes:t}=this;if(0===t.length)throw Error("There are no nodes in this file!");let[e]=t;const i=new Map;t.forEach((t=>{const n={node:t,children:[]};if(i.set(t.index,n),-1===t.parent)e=t;else if(t.index===t.parent)console.error(`Node #${t.index} has itself has a parent!`);else{const e=i.get(t.parent);e?e.children.push(n):console.error(`Node #${t.index} has #${t.parent} as a parent, which is not yet defined!`)}}));const n=i.get(e.index);if(!n)throw Error("Impossible error! There must be a bug in CellNodes.buildTree().");return n}}function B(t,e,i){if(t.parent<0)return 0;if(i.has(t.index))return i.get(t.index);const n=e.get(t.parent);if(!n)return 0;const s=n.x-t.x,r=n.y-t.y,a=n.z-t.z,o=Math.sqrt(s*s+r*r+a*a)+B(n,e,i);return i.set(t.index,o),o}class C{constructor(t,e=0){this.onChange=t,this._value=0,this._value=e}set(t){this._value!==t&&(this._value=t,this.onChange(this))}get(){return this._value}}class T{constructor(t,e=0,i=0){this.onChange=t,this._width=0,this._height=0,this._width=e,this._height=i}get width(){return this._width}set width(t){t!==this._width&&(this._width=t,this.onChange(this))}get height(){return this._height}set height(t){t!==this._height&&(this._height=t,this.onChange(this))}}class P{constructor(t,e=0,i=0,n=0){this.onChange=t,this._x=0,this._y=0,this._z=0,this._x=e,this._y=i,this._z=n}set([t,e,i]){this._x=t,this._y=e,this._z=i,this.onChange(this)}setYZX([t,e,i]){this._x=e,this._y=i,this._z=t,this.onChange(this)}asArray(){return[this._x,this._y,this._z]}asVec3(){return w(this._x,this._y,this._z)}get x(){return this._x}set x(t){t!==this._x&&(this._x=t,this.onChange(this))}get y(){return this._y}set y(t){t!==this._y&&(this._y=t,this.onChange(this))}get z(){return this._z}set z(t){t!==this._z&&(this._z=t,this.onChange(this))}}function D(){var t=new g(16);return g!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function R(){var t=new g(9);return g!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function S(){var t=new g(4);return g!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}A=new g(4),g!=Float32Array&&(A[0]=0,A[1]=0,A[2]=0,A[3]=0);y(),w(1,0,0),w(0,1,0),S(),S(),R();class U{constructor(){this.listeners=new Set}addListener(t){this.listeners.add(t)}removeListener(t){this.listeners.delete(t)}dispatch(t){this.listeners.forEach((e=>e(t)))}}w(1,0,0),w(0,1,0),w(0,0,1);class z{constructor(){this.dirty=!0,this.matrixView=D(),this.matrixProjection=D(),this.orientation=S(),this.axis=R(),this.axisX=y(),this.axisY=y(),this.axisZ=y(),this.position=y(),this.eventChange=new U,this.handleDirty=()=>{this.dirty=!0,this.eventChange.dispatch(this)},this.zoom=new C(this.handleDirty,1),this.target=new P(this.handleDirty,0,0,0),this.viewport=new T(this.handleDirty,1,1),this.near=new C(this.handleDirty,.001),this.far=new C(this.handleDirty,1e6),this.facePosZ()}setUniforms(t,e,i){const{matrixView:n,matrixProjection:s}=this;this.updateIfDirty(),t.uniformMatrix4fv(e,!1,n),t.uniformMatrix4fv(i,!1,s)}facePosZ(){var t;(t=this.orientation)[0]=0,t[1]=0,t[2]=0,t[3]=1,this.handleDirty()}rotateAroundXY(t,e){this.updateIfDirty();const{axisX:i,axisY:n,axisZ:s}=this;I(n,i,t),I(s,i,t),I(i,n,e),I(s,n,e),this.axis[0]=i[0],this.axis[1]=i[1],this.axis[2]=i[2],this.axis[3]=n[0],this.axis[4]=n[1],this.axis[5]=n[2],this.axis[6]=s[0],this.axis[7]=s[1],this.axis[8]=s[2],function(t,e){var i,n=e[0]+e[4]+e[8];if(n>0)i=Math.sqrt(n+1),t[3]=.5*i,i=.5/i,t[0]=(e[5]-e[7])*i,t[1]=(e[6]-e[2])*i,t[2]=(e[1]-e[3])*i;else{var s=0;e[4]>e[0]&&(s=1),e[8]>e[3*s+s]&&(s=2);var r=(s+1)%3,a=(s+2)%3;i=Math.sqrt(e[3*s+s]-e[3*r+r]-e[3*a+a]+1),t[s]=.5*i,i=.5/i,t[3]=(e[3*r+a]-e[3*a+r])*i,t[r]=(e[3*r+s]+e[3*s+r])*i,t[a]=(e[3*a+s]+e[3*s+a])*i}}(this.orientation,this.axis),function(t,e){var i=e[0],n=e[1],s=e[2],r=e[3],a=i*i+n*n+s*s+r*r;a>0&&(a=1/Math.sqrt(a)),t[0]=i*a,t[1]=n*a,t[2]=s*a,t[3]=r*a}(this.orientation,this.orientation),this.handleDirty()}updateIfDirty(){this.dirty&&(this.dirty=!1,this.updateView(),this.updateProjection())}}function I(t,e,i){const[n,s,r]=e,a=Math.cos(i),o=Math.sin(i);var h,c,u,l,f,d,v,m,p,y;E(t,t,(h=a+(1-a)*n*n,c=(1-a)*n*s+o*r,u=(1-a)*n*r-o*s,l=(1-a)*n*s-o*r,f=a+(1-a)*s*s,d=(1-a)*s*r+o*n,v=(1-a)*n*r+o*s,m=(1-a)*s*r-o*n,p=a+(1-a)*r*r,(y=new g(9))[0]=h,y[1]=c,y[2]=u,y[3]=l,y[4]=f,y[5]=d,y[6]=v,y[7]=m,y[8]=p,y))}w(1,0,0),w(0,1,0),w(0,0,1);const L=w(1,0,0),F=w(0,1,0),O=w(0,0,1);class Y extends z{constructor(){super(),this.height=new C(this.handleDirty)}updateProjection(){const t=this.viewport.width/this.viewport.height,e=this.zoom.get()*this.height.get(),i=t*e,n=this.near.get(),s=this.far.get();var r,a,o,h,c;a=2/i,o=2/e,h=-2/(s-n),c=-2/(s+n),(r=this.matrixProjection)[0]=a,r[1]=0,r[2]=0,r[3]=0,r[4]=0,r[5]=o,r[6]=0,r[7]=0,r[8]=0,r[9]=0,r[10]=h,r[11]=0,r[12]=0,r[13]=0,r[14]=c,r[15]=1}updateView(){const t=this.near.get(),e=this.far.get(),i=Math.abs(e-t);var n,s,r,a,o,h,c,u,l,f,d,v,m,g,y,x,w,b;n=this.axis,f=(r=(s=this.orientation)[0])*(c=r+r),d=(a=s[1])*c,v=a*(u=a+a),m=(o=s[2])*c,g=o*u,y=o*(l=o+o),x=(h=s[3])*c,w=h*u,b=h*l,n[0]=1-v-y,n[3]=d-b,n[6]=m+w,n[1]=d+b,n[4]=1-f-y,n[7]=g-x,n[2]=m-w,n[5]=g+x,n[8]=1-f-v,E(this.axisX,L,this.axis),E(this.axisY,F,this.axis),E(this.axisZ,O,this.axis),function(t,e,i,n){t[0]=e[0]+i[0]*n,t[1]=e[1]+i[1]*n,t[2]=e[2]+i[2]*n}(this.position,this.target.asVec3(),this.axisZ,.25*i+t),function(t,e,i,n){var s,r,a,o,h,c,u,l,f,d,v=e[0],m=e[1],g=e[2],y=n[0],x=n[1],w=n[2],b=i[0],_=i[1],E=i[2];Math.abs(v-b)<p&&Math.abs(m-_)<p&&Math.abs(g-E)<p?function(t){t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1}(t):(u=v-b,l=m-_,f=g-E,s=x*(f*=d=1/Math.hypot(u,l,f))-w*(l*=d),r=w*(u*=d)-y*f,a=y*l-x*u,(d=Math.hypot(s,r,a))?(s*=d=1/d,r*=d,a*=d):(s=0,r=0,a=0),o=l*a-f*r,h=f*s-u*a,c=u*r-l*s,(d=Math.hypot(o,h,c))?(o*=d=1/d,h*=d,c*=d):(o=0,h=0,c=0),t[0]=s,t[1]=o,t[2]=u,t[3]=0,t[4]=r,t[5]=h,t[6]=l,t[7]=0,t[8]=a,t[9]=c,t[10]=f,t[11]=0,t[12]=-(s*v+r*m+a*g),t[13]=-(o*v+h*m+c*g),t[14]=-(u*v+l*m+f*g),t[15]=1)}(this.matrixView,this.position,this.target.asArray(),this.axisY),console.log("🚀 [camera-orthographic] this.position = ",this.position),console.log("🚀 [camera-orthographic] this.target.asArray() = ",this.target.asArray())}}class V{constructor(t){this.options=t,this.start={x:0,y:0,t:0},this.current={x:0,y:0,t:0},this.previous={x:0,y:0,t:0},this.canvas=null,this.active=!1,this.canvasX=0,this.canvasY=0,this.screenX=0,this.screenY=0,this.handleCanvasWheel=t=>{const{onZoom:e}=this.options;e&&(t.preventDefault(),e(t.deltaY))},this.handleCanvasPointerDown=t=>{this.canvasX=t.clientX,this.canvasY=t.clientY,this.active=!0},this.handlePointerDown=t=>{var e,i;if(!this.active)return;this.screenX=t.clientX,this.screenY=t.clientY;const n=this.getPoint(t);this.start=this.current=n,null===(i=(e=this.options).onMoveStart)||void 0===i||i.call(e,n)},this.handlePointerMove=t=>{var e,i;this.active&&this.canvas&&(this.previous=this.current,this.current=this.getPoint(t),null===(i=(e=this.options).onMove)||void 0===i||i.call(e,this))},this.handlePointerUp=t=>{var e,i;this.active&&(null===(i=(e=this.options).onMoveEnd)||void 0===i||i.call(e,this.getPoint(t)),this.active=!1)},t.canvas&&this.attach(t.canvas)}attach(t){this.detach(),this.canvas=t,t.addEventListener("pointerdown",this.handleCanvasPointerDown,!0),t.addEventListener("wheel",this.handleCanvasWheel),document.addEventListener("pointerdown",this.handlePointerDown),document.addEventListener("pointermove",this.handlePointerMove),document.addEventListener("pointerup",this.handlePointerUp)}detach(){const{canvas:t}=this;t&&(t.removeEventListener("pointerdown",this.handleCanvasPointerDown),t.removeEventListener("wheel",this.handleCanvasWheel),document.removeEventListener("pointerdown",this.handlePointerDown),document.removeEventListener("pointermove",this.handlePointerMove),document.removeEventListener("pointerup",this.handlePointerUp),this.canvas=null)}getPoint(t){if(!this.canvas)throw Error("No canvas has been defined!");const{left:e,top:i,width:n,height:s}=this.canvas.getBoundingClientRect();return{x:2*((this.canvasX+t.clientX-this.screenX-e)/n-.5),y:-2*((this.canvasY+t.clientY-this.screenY-i)/s-.5),t:t.timeStamp}}}class X{constructor(t,e={}){this.camera=t,this.options=e,this.handleZoom=t=>{const e=t>0?1.1:.9,i=this.camera.zoom.get();this.camera.zoom.set(i*e)},this.handleStart=()=>{},this.handleMove=({previous:t,current:e})=>{const i=e.x-t.x,n=5*(e.y-t.y),s=5*-i;this.camera.rotateAroundXY(n,s)},this.gestures=new V({onMoveStart:this.handleStart,onMove:this.handleMove,onZoom:this.handleZoom})}attach(t){this.gestures.attach(t);const{onChange:e}=this.options;e&&this.camera.eventChange.addListener(e)}detach(){this.gestures.detach();const{onChange:t}=this.options;t&&this.camera.eventChange.removeListener(t)}}function N(t,e,i){var n;const s=t.createShader("vertex"===e?t.VERTEX_SHADER:t.FRAGMENT_SHADER);if(!s)throw Error("Unable to create a Vertex Shader handle!");t.shaderSource(s,i),t.compileShader(s);const r=null!==(n=t.getShaderInfoLog(s))&&void 0!==n?n:"";if(r.length>0){console.error("Shader error!",r);const t=$(r);throw Z(`${e.toUpperCase()} Shader`,i,...t),Error(`Error in ${e.toUpperCase()} shader: ${r}`)}return s}const k=/^ERROR:[ \t]+([0-9]+):([0-9]+):/g;function $(t){const e=[];for(const i of t.split("\n")){k.lastIndex=-1;const t=k.exec(i);t&&e.push(parseInt(t[2],10))}return e}function W(t,e=!1){return`color:#fff;background:${t};font-family:monospace;font-size:80%;font-weight:${e?"bolder":"100"}`}function Z(t,e,...i){console.log(`%c${t}`,"font-weight:bolder;font-size:120%"),e.split("\n").forEach(((t,e)=>{const n=e+1,s=(1e-4*n).toFixed(4).substring(2),r=i.includes(n)?"#f00":"#000";console.log(`%c${s}  %c${t}`,W(r),W(r,!0))}))}class j{constructor(t){this.gl=t,this.programs=new Set,this.buffers=new Set}cleanUp(){const{gl:t}=this;this.programs.forEach((({prg:e,shaders:i})=>{i.forEach((e=>t.deleteShader(e))),t.deleteProgram(e)})),this.buffers.forEach((e=>t.deleteBuffer(e)))}createProgram(t){const{prg:e,shaders:i}=function(t,e){var i;const n=t.createProgram();if(!n)throw Error("Unable to create a WebGL program!");const s=N(t,"vertex",e.vert);t.attachShader(n,s);const r=N(t,"fragment",e.frag);if(t.attachShader(n,r),t.linkProgram(n),!t.getProgramParameter(n,t.LINK_STATUS)){const s=null!==(i=t.getProgramInfoLog(n))&&void 0!==i?i:"";console.warn(s);const r=$(s);throw Z("Vertex Shader",e.vert,...r),Z("Fragment Shader",e.frag,...r),new Error("Could NOT link WebGL2 program!\n"+s)}return{prg:n,shaders:[s,r]}}(this.gl,t);return this.programs.add({prg:e,shaders:i}),e}createBuffer(){const t=this.gl.createBuffer();if(!t)throw Error("Unable to create a WebGLBuffer!");return this.buffers.add(t),t}createVAO(t,...e){const{gl:i}=this,n=i.createVertexArray();if(!n)throw Error("Unable to create VertexArrayObject!");i.bindVertexArray(n);let s=!1;for(const n of e)if("function"==typeof n)n(this);else if(n instanceof Uint8Array||n instanceof Uint16Array||n instanceof Uint32Array){if(s)throw Error("createVAO() can have only one UintArray in the arguments!");s=!0;const t=this.createBuffer();i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,t),i.bufferData(i.ELEMENT_ARRAY_BUFFER,n,i.STATIC_DRAW)}else n.buffer||(n.buffer=this.createBuffer()),n.update(i),i.bindBuffer(i.ARRAY_BUFFER,n.buffer),n.define(i,t);return i.bindVertexArray(null),n}getUniformsLocations(t){const{gl:e}=this,i=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);if("number"!=typeof i)throw Error("Unable to get the number of uniforms in a WebGLProgram!");const n={};for(let s=0;s<i;s++){const i=e.getActiveUniform(t,s);if(!i)continue;const r=e.getUniformLocation(t,i.name);if(null===r)throw Error(`Unable to get location for uniform "${i.name}"!`);n[i.name]=r}return n}}class H{constructor(){this.eventPixelScaleChange=new U,this.previousCameraHeight=-1,this.previousCameraZoom=-1,this.previousViewportHeight=-1,this._swc=null,this._canvas=null,this.nodes=null,this.paintingIsScheduled=!1,this.painter=null,this._colorBy="section",this._radiusType=0,this._radiusMultiplier=1,this.resetCamera=()=>{const t=this._camera;t.facePosZ();const{nodes:e}=this;if(e){const[i,n]=e.bbox,s=2*Math.abs(i),r=2*Math.abs(n),a=s/r,o=t.viewport.width/t.viewport.height,h=o>a?r:r*a/o;t.height.set(1.05*h),t.zoom.set(1)}},this.paint=()=>{this.paintingIsScheduled||(this.paintingIsScheduled=!0,window.requestAnimationFrame(this.actualPaint))},this.actualPaint=t=>{var e;this.paintingIsScheduled=!1,null===(e=this.painter)||void 0===e||e.paint(t)},this.handleColorsChange=()=>{var t;null===(t=this.painter)||void 0===t||t.resetColors(this.colors)},this.handlePixelScaleDispatch=()=>{console.log("handlePixelScaleDispatch");const t=this._camera,e=t.height.get(),i=t.zoom.get(),n=t.viewport.height;e!==this.previousCameraHeight||i!==this.previousCameraZoom||n!==this.previousViewportHeight?(this.previousCameraHeight=e,this.previousCameraZoom=i,this.previousViewportHeight=n,this.eventPixelScaleChange.dispatch(this.pixelScale)):console.log("No change...")},this._camera=new Y,this.orbiter=new X(this._camera,{onChange:this.paint}),this.colors=new i(this.handleColorsChange)}get pixelScale(){const t=this._camera;return t.height.get()*t.zoom.get()/t.viewport.height}computeScalebar(t={}){return function(t,{preferedSizeInPixels:e=240,units:i={nm:.001,µm:1,mm:1e3,m:1e6,km:1e9},values:n=[1,2,5,10,20,25,50,75,100,200,300,400,500,600,700,800,900]}={}){var s;const r=t*e;for(const e of Object.keys(i)){const a=null!==(s=i[e])&&void 0!==s?s:1,o=r/a;for(const i of n)if(i>=o)return{sizeInPixel:i*a/t,value:i,unit:e}}return null}(this.pixelScale,t)}get colorBy(){var t,e;return null!==(e=null===(t=this.painter)||void 0===t?void 0:t.colorBy)&&void 0!==e?e:this._colorBy}set colorBy(t){const{painter:e}=this;this._colorBy=t,e&&(e.colorBy=t)}get radiusType(){var t,e;return null!==(e=null===(t=this.painter)||void 0===t?void 0:t.radiusType)&&void 0!==e?e:this._radiusType}set radiusType(t){const{painter:e}=this;this._radiusType=t,e&&(e.radiusType=t)}get radiusMultiplier(){var t,e;return null!==(e=null===(t=this.painter)||void 0===t?void 0:t.radiusMultiplier)&&void 0!==e?e:this._radiusMultiplier}set radiusMultiplier(t){const{painter:e}=this;this._radiusMultiplier=t,e&&(e.radiusMultiplier=t)}get canvas(){return this._canvas}set canvas(t){t!==this._canvas&&(this._camera.eventChange.removeListener(this.paint),this._camera.eventChange.removeListener(this.handlePixelScaleDispatch),this.orbiter.detach(),t&&(this.orbiter.attach(t),this._camera.eventChange.addListener(this.paint),this._camera.eventChange.addListener(this.handlePixelScaleDispatch)),this._canvas=t,this.init())}get swc(){return this._swc}set swc(t){if(t!==this._swc&&(this._swc=t,this.nodes=null,t)){const e=new M(function(t){const e=[];for(const i of n(t)){const t=l(i).split(/\s+/);if(t.length<7)continue;const[n,s,r,a,h,c,u]=t.map((t=>Number(t))),d=s>0&&s<5?s:o.Unknown;e.push({index:n,parent:u,type:d,x:r,y:a,z:h,radius:c,u:0,v:f(d)})}return e}(t));e.computeDistancesFromSoma(),this.nodes=e,this.init()}}init(){const{canvas:t,nodes:e}=this;if(!t||!e)return;this.painter&&this.painter.cleanUp();const i=this._camera,[n,s,r]=e.center,[a,o,h]=e.bbox;i.near.set(1e-6),i.far.set(1e3*Math.max(a,o,h)),i.target.set([n,s,r]),i.height.set(h+Math.max(a,o)),window.requestAnimationFrame(this.resetCamera);const c=t.getContext("webgl2");if(!c)throw Error("Unable to create WebGL2 context!");const u=new j(c);this.painter=new m(u,e,i),this.colors&&this.painter.resetColors(this.colors)}}var G=e.$;export{G as MorphologyPainter};