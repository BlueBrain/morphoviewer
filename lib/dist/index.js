var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{$:()=>Z});const n=function*(t){const e=t.length;let n=0,i=0;for(;n>-1&&n<e&&(n=t.indexOf("\n",i),!(n<0));)yield t.substring(i,n).trim(),i=n+1;return t.substring(i).trim()};function i(t){return 3===t.length}function r(t,e){const n=[];if(e)for(let i=0;i<t;i++)n.push(e(i));else for(let e=0;e<t;e++)n.push(e);return n}var s,a;!function(t){t[t.X=0]="X",t[t.Y=1]="Y",t[t.Z=2]="Z",t[t.W=3]="W"}(s||(s={}));class o{constructor(t,e=0){this.divisor=e,this.buffer=null,this.arrayBuffer=null,this.data={},this.verticeCount=0;let n=0;const i={},r={};for(const s of Object.keys(t)){i[s]=new ArrayBuffer(0);const a=h(t[s],e,n);r[s]=a,n+=a.bytesPerElement*a.dimension}this.data=i,this.definitions=r,this.stride=n}getVerticeCount(){return this.verticeCount}debug(){const{definitions:t,verticeCount:e}=this;console.log("Vertices count:",e);const n=new Float32Array(this.get());console.log(n);for(const n of Object.keys(t)){const i=t[n];console.log(n,r(e).map((t=>r(i.dimension).map((e=>this.peek(n,t,e))))))}}getNames(){return Object.keys(this.definitions)}getDefinitions(){return structuredClone(this.definitions)}getAttribDef(t){const e=this.definitions[t];return e?structuredClone(e):void 0}getGlslType(t){const e=this.definitions[t];if(!e)return`/* "${t}" not found! */`;switch(e.dimension){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:return`/* Don't know how to deal with dimension ${e.dimension}! */`}}get(t=0){const e=t>0?t:this.verticeCount,n=this.stride*e;if(!this.arrayBuffer||this.arrayBuffer.byteLength<n){this.checkIfWeHaveEnoughData(e),this.arrayBuffer=new ArrayBuffer(n);const t=new DataView(this.arrayBuffer);let i=0;const{data:r,definitions:s}=this;for(let n=0;n<e;n++)for(const e of Object.keys(s)){const a=s[e],o=r[e],h=new DataView(o);let c=a.bytesPerElement*a.dimension*n;for(let e=0;e<a.dimension;e++)a.setter(t,i,a.getter(h,c)),c+=a.bytesPerElement,i+=a.bytesPerElement}}return this.arrayBuffer}update(t,e=0,n=!1){const i=this.getBuffer(),r=e>0?e:this.verticeCount,s=this.get(r);return t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,s,n?t.DYNAMIC_DRAW:t.STATIC_DRAW),s}define(t,e){const{buffer:n}=this;n&&t.bindBuffer(t.ARRAY_BUFFER,n);let i=0;const{definitions:r}=this;for(const n of Object.keys(r)){const s=r[n],a=t.getAttribLocation(e,n);if(a<0)throw Error(c(n));t.enableVertexAttribArray(a),t.vertexAttribPointer(a,s.dimension,t.FLOAT,!1,this.stride,i),t.vertexAttribDivisor(a,s.divisor),i+=s.dimension*s.bytesPerElement}}set(t,e){var n;(n=e)&&"object"==typeof n&&e.buffer instanceof ArrayBuffer&&(e=e.buffer),this.data[t]=e;const{bytesPerElement:i,dimension:r}=this.definitions[t];this.verticeCount=Math.max(this.verticeCount,Math.ceil(e.byteLength/(i*r))),this.arrayBuffer=null}poke(t,e,n,i){if(e>=this.verticeCount)return;const r=this.get(this.verticeCount),s=new DataView(r),{setter:a,bytesPerElement:o,bytesOffset:h}=this.definitions[t];a(s,h+e*this.stride+o*n,i)}peek(t,e,n){if(e>=this.verticeCount)return 0;const i=this.get(this.verticeCount),r=new DataView(i),{getter:s,bytesPerElement:a,bytesOffset:o}=this.definitions[t];return s(r,o+e*this.stride+a*n)}getBuffer(){const{buffer:t}=this;if(!t)throw Error(`Wgl2Attribute.buffer has not been set!\n${JSON.stringify(this.definitions,null,"  ")}`);return t}checkIfWeHaveEnoughData(t){const{data:e,definitions:n}=this;for(const i of Object.keys(n)){const r=e[i];if(!r)throw Error(`No data has been set for attribute "${i}"!\nPlease use something like this:\n    data.set("${i}", new Float32Array([4, 3]))`);const s=n[i],a=s.bytesPerElement*s.dimension*t;if(r.byteLength<a)throw Error(`Attribute "${i}" has only ${r.byteLength} bytes, but we need at least ${a} since you asked for ${t} vertices!`)}}}function h(t,e,n){const i="number"==typeof t?{dimension:t,type:"float"}:Object.assign({type:"float",dimension:1},t);if("float"===i.type)return function(t,e,n){const i=Float32Array.BYTES_PER_ELEMENT;return{dimension:t.dimension,divisor:e,bytesPerElement:i,bytesOffset:n,getter:(t,e)=>t.getFloat32(e,!0),setter(t,e,n){t.setFloat32(e,n,!0)}}}(i,e,n);throw Error(`Unable to create a Data for an attribute of type "${i.type}"!`)}function c(t){return`Unable to find atribute "${t}"!`}function u(t){const e=t.indexOf("#");return e<0?t:t.substring(0,e).trim()}function l(t){return(function(t){switch(t){case a.Soma:return 0;case a.Axon:return 1;case a.ApicalDendrite:return 2;case a.BasalDendrite:return 3;default:return 4}}(t)+.5)/5}!function(t){t[t.Soma=1]="Soma",t[t.Axon=2]="Axon",t[t.BasalDendrite=3]="BasalDendrite",t[t.ApicalDendrite=4]="ApicalDendrite",t[t.Unknown=666]="Unknown"}(a||(a={}));class f{constructor(t){this.nodes=t,this._count=0,this.nodesXYZR=[],this.nodesUV=[],this.nodesInfluence=[],this.attAxyzr=[],this.attBxyzr=[],this.attAuv=[],this.attBuv=[],this.attAinfluence=[],this.attBinfluence=[],this.elemByIndex=new Map,t.forEach((({index:t,type:e,x:n,y:i,z:r,radius:s,u:o,v:h})=>{const c=this.nodesUV.length;this.nodesXYZR.push([n,i,r,s]),this.nodesUV.push([o,h]),this.nodesInfluence.push(e===a.Soma?0:1),this.elemByIndex.set(t,c)}))}get count(){return this._count}addSegment(t,e){const n=this.elemByIndex.get(t);if("number"!=typeof n)return;const i=this.elemByIndex.get(e);if("number"!=typeof i)return;const r=this.nodesXYZR[n],s=this.nodesXYZR[i];this.attAxyzr.push(...r),this.attBxyzr.push(...s);const a=this.nodesUV[n],o=this.nodesUV[i];this.attAuv.push(...a),this.attBuv.push(...o),this.attAinfluence.push(this.nodesInfluence[n]),this.attBinfluence.push(this.nodesInfluence[i]),this._count++}makeAttributes(t=1){const e=new o({attAxyzr:4,attBxyzr:4,attAuv:2,attBuv:2,attAinfluence:1,attBinfluence:1},t);return e.set("attAxyzr",new Float32Array(this.attAxyzr)),e.set("attBxyzr",new Float32Array(this.attBxyzr)),e.set("attAuv",new Float32Array(this.attAuv)),e.set("attBuv",new Float32Array(this.attBuv)),e.set("attAinfluence",new Float32Array(this.attAinfluence)),e.set("attBinfluence",new Float32Array(this.attBinfluence)),e}}function d(t,e){const n=document.createElement("canvas");if(!n)throw Error("Unable to create a HTMLCanvasElement!");n.width=t,n.height=e;const i=n.getContext("2d");if(!i)throw Error("Unable to create a 2D context!");return i}class v{constructor(t,e,r){this.resources=t,this.camera=r,this.gl=null,this.prg=null,this.vao=null,this.texture=null,this.locations={},this.instancesCount=0,this._radiusMultiplier=1,this._radiusType=0,this._colorBy="section",this.textureIsOutOfDate=!0,this.paint=t=>{const e=1-this._radiusType,n=this._radiusType,{gl:i,camera:r,locations:s,textureIsOutOfDate:a,texture:o,colorBy:h}=this;i&&(r.viewport.width=i.drawingBufferWidth,r.viewport.height=i.drawingBufferHeight,i.useProgram(this.prg),o&&a&&(i.bindTexture(i.TEXTURE_2D,o),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,"section"===h?function(){const t=d(1,5);return["#0f0","#f00","#0bb","#33f","#777"].forEach(((e,n)=>{t.fillStyle=e;const i=n;t.fillRect(0,i,1,i+1)})),t.canvas}():function(){const t=d(256,1),e=["#0f0","#ff0","#f00"],n=t.createLinearGradient(0,0,256,1);return e.forEach(((t,i)=>{n.addColorStop(i/(e.length-1),t)})),t.fillStyle=n,t.fillRect(0,0,256,1),t.canvas}()),this.textureIsOutOfDate=!1),r.setUniforms(i,s.uniModelViewMatrix,s.uniProjectionMatrix),i.uniform1f(s.uniAspect,i.drawingBufferWidth/i.drawingBufferHeight),i.enable(i.DEPTH_TEST),i.clearDepth(1),i.depthFunc(i.LESS),i.depthMask(!0),i.depthRange(0,1),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT),i.bindVertexArray(this.vao),i.uniform1f(s.uniRadiusMultiplier,this._radiusMultiplier*e),i.uniform1f(s.uniRadiusAdditioner,this.averageRadius*this._radiusMultiplier*n),i.uniform1f(s.uniLightness,1),i.uniform1f(s.uniZFight,0),i.uniform1f(s.uniOutline,1),i.drawElementsInstanced(i.TRIANGLES,48,i.UNSIGNED_BYTE,0,this.instancesCount),i.uniform1f(s.uniOutline,1.2),i.uniform1f(s.uniLightness,0),i.uniform1f(s.uniZFight,1),i.drawElementsInstanced(i.TRIANGLES,48,i.UNSIGNED_BYTE,0,this.instancesCount))},this.handleResize=()=>{const{canvas:t,gl:e}=this,n=t.clientWidth,i=t.clientHeight;t.width=n,t.height=i,null==e||e.viewport(0,0,n,i),this.refresh()};const{gl:s}=t;this.gl=s,this.observer=new ResizeObserver(this.handleResize);const a=s.canvas;if(!(a instanceof HTMLCanvasElement))throw Error("This painter works only with a real HTMLCanvasElement!");this.canvas=a,this.observer.observe(a),this.resources=t,this.averageRadius=e.averageRadius;const h=t.createProgram({vert:"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uniTexture;\nuniform mat4 uniModelViewMatrix;\nuniform mat4 uniProjectionMatrix;\nuniform float uniAspect;\nuniform float uniRadiusMultiplier;\nuniform float uniRadiusAdditioner;\nuniform float uniOutline;\nuniform float uniLightness;\nuniform float uniZFight;\nin vec4 attAxyzr;\nin vec4 attBxyzr;\nin vec2 attAuv;\nin vec2 attBuv;\nin float attAinfluence;\nin float attBinfluence;\nin float attCenter;\nin vec2 attOffset;\nout vec3 varColor;\n\nconst float EPSILON = 1e-5;\n\nfloat scaleRadius(float radius, float influence) {\n    float multiplier = mix(1.0, uniRadiusMultiplier, influence);\n    float additioner = uniRadiusAdditioner * influence;\n    return (radius * multiplier + additioner) * mix(1.0, uniOutline, influence);\n}\n\nvec2 safeNormalize(vec2 v) {\n    float len2 = dot(v, v);\n    if (len2 < 1e-6) return vec2(0, 1);\n\n    return inversesqrt(len2) * v;\n}\n\nvoid main() {\n    vec2 uv = attCenter == 0.0 ? attAuv : attBuv;\n    varColor = texture(uniTexture, uv).rgb * uniLightness;\n\n    vec4 X = uniModelViewMatrix[0];\n    vec4 cameraA = uniModelViewMatrix * vec4(attAxyzr.xyz, 1.0);\n    vec4 screenA = uniProjectionMatrix * cameraA;\n    vec4 cameraB = uniModelViewMatrix * vec4(attBxyzr.xyz, 1.0);\n    vec4 screenB = uniProjectionMatrix * cameraB;\n    // // Shading\n    // vec3 axisY = normalize((cameraB - cameraA).xyz);\n    // vec3 axisX = normalize(vec3(axisY.y, -axisY.x, 0.0));\n    // varColor *= mix(1.2, 0.8, axisY.z);\n    // Is A or B the center here?\n    vec4 center = attCenter == 0.0 ? screenA : screenB;\n    float radius = attCenter == 0.0 \n        ? scaleRadius(attAxyzr.w, attAinfluence) \n        : scaleRadius(attBxyzr.w, attBinfluence);\n    // 2D Axis in screen space: screenAxisY is aligned with the segment\n    // from A to B.\n    vec2 screenAxisY = safeNormalize(screenB.xy / screenB.z - screenA.xy / screenA.z) * radius;\n    vec2 screenAxisX = vec2(screenAxisY.y, -screenAxisY.x);\n    // Each point is offset from a center.\n    // This allows thickness variation in the shader.\n    vec2 screenOffset = attOffset.x * screenAxisX + attOffset.y * screenAxisY;\n    center.x += screenOffset.x;\n    center.y += screenOffset.y * uniAspect;\n    // Prevent Z fight.\n    center.z += uniZFight * EPSILON; // EPSILON * (attCenter + uniZFight);\n    gl_Position = center;\n}\n",frag:"#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D uniTexture;\n\nin vec3 varColor;\nout vec4 FragColor;\n\n\nvoid main() {\n    FragColor = vec4(varColor, 1.0);\n}\n"});this.prg=h,this.locations=t.getUniformsLocations(h);const{attributes:c,elements:u}=function(){const{vertices:t,faces:e}=function(t){const e=[],r=[];for(const t of n("# Blender 4.0.1\n# www.blender.org\no Circle\nv 0.000000 2.000000 0.000000\nv -0.500000 1.866025 0.000000\nv -0.866025 1.500000 0.000000\nv -1.000000 1.000000 0.000000\nv -0.500000 -1.933013 0.000000\nv -0.866025 -1.566987 0.000000\nv -1.000000 -1.066987 0.000000\nv 1.000000 -1.066987 0.000000\nv 0.866025 -1.566987 0.000000\nv 1.000000 1.000000 0.000000\nv 0.866025 1.500000 0.000000\nv 0.500000 1.866025 0.000000\nv 0.500000 -1.933013 0.000000\nv -0.000000 -2.066987 0.000000\nv 0.000000 1.000000 0.000000\nv 0.000000 -1.066987 0.000000\ns 0\nf 3 15 4\nf 2 15 3\nf 1 15 2\nf 12 15 1\nf 11 15 12\nf 10 15 11\nf 9 16 8\nf 13 16 9\nf 14 16 13\nf 5 16 14\nf 6 16 5\nf 7 16 6\nf 4 16 7\nf 4 15 16\nf 16 15 8\nf 15 10 8\n")){if(t.startsWith("v ")){const n=t.substring(2).split(" ").map((t=>Number(t)));i(n)&&e.push(n)}if(t.startsWith("f ")){const e=t.substring(2).split(" ").map((t=>Number(t)-1));if(!i(e))throw Error(`This simple Wavefront parser accepts only triangles!\n${t}`);r.push(...e)}}return{vertices:e,faces:r}}(),r=new o({attCenter:1,attOffset:2}),s=[],a=[];for(const[e,n]of t){const t=n>0;s.push(t?1:0),a.push(e,n-(t?1:-1))}return r.set("attCenter",new Float32Array(s)),r.set("attOffset",new Float32Array(a)),{attributes:r,elements:new Uint8Array(e)}}(),l=new f(e);e.forEach((({index:t,parent:e,type:n,radius:i,x:r,y:s,z:a})=>{e<0||l.addSegment(t,e)})),this.instancesCount=l.count;const v=l.makeAttributes();this.vao=t.createVAO(h,c,v,new Uint8Array(u)),s.clearColor(1,1,1,1),this.texture=function(t){const e=t.createTexture();if(!e)throw Error("Unable to create a WebGLTexture!");return t.activeTexture(t.TEXTURE0+0),t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),e}(s)}get colorBy(){return this._colorBy}set colorBy(t){t!==this._colorBy&&(this._colorBy=t,this.textureIsOutOfDate=!0,this.refresh())}get radiusType(){return this._radiusType}set radiusType(t){t!==this._radiusType&&(this._radiusType=t,this.refresh())}get radiusMultiplier(){return this._radiusMultiplier}set radiusMultiplier(t){this._radiusMultiplier!==t&&(this._radiusMultiplier=t,this.refresh())}cleanUp(){this.resources.cleanUp(),this.observer.unobserve(this.canvas)}refresh(){window.requestAnimationFrame(this.paint)}}class m{constructor(t,e){this.res=t,this.camera=e,this.x=0,this.y=0,this.z=0,this.gl=null,this.prg=null,this.vao=null,this.locations={},this.gl=t.gl;const n=new o({attPos:3,attCol:3}),i=[],r=[];let s=0;const a=(t,e,n,a,o,h,[c,u,l])=>{i.push(t,e,n,a,o,h),r.push(c,u,l,c,u,l),s+=2},h=[1,0,0],c=[0,1,0],u=[.5,.5,.5];for(let t=-10;t<=10;t++)a(-10,t,0,10,t,0,0===t?h:u),a(t,-10,0,t,10,0,0===t?c:u);n.set("attPos",new Float32Array(i)),n.set("attCol",new Float32Array(r)),this.count=s,this.prg=t.createProgram({vert:"#version 300 es\n\nprecision mediump float;\n\nuniform mat4 uniModelViewMatrix;\nuniform mat4 uniProjectionMatrix;\nuniform vec3 uniCenter;\n\nin vec3 attPos;\nin vec3 attCol;\nout vec3 varColor;\n\nconst float EPSILON = 0.0;\n\nvoid main() {\n    varColor = attCol;\n    // Project in screen space.\n    gl_Position = uniProjectionMatrix * uniModelViewMatrix * vec4(attPos + uniCenter, 1.0);\n}\n",frag:"#version 300 es\n\nprecision mediump float;\n\nin vec3 varColor;\nout vec4 FragColor;\n\n\nvoid main() {\n    FragColor = vec4(varColor, 1.0);\n}\n"}),this.locations=t.getUniformsLocations(this.prg),this.vao=t.createVAO(this.prg,n)}paint(){const{gl:t,camera:e,locations:n}=this;t&&(t.useProgram(this.prg),t.uniform3f(n.uniCenter,this.x,this.y,this.z),e.setUniforms(t,n.uniModelViewMatrix,n.uniProjectionMatrix),t.bindVertexArray(this.vao),t.drawArrays(t.LINES,0,this.count))}}var p=1e-6,g="undefined"!=typeof Float32Array?Float32Array:Array;function y(){var t=new g(3);return g!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function x(t){var e=new g(3);return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function w(t,e,n){var i=new g(3);return i[0]=t,i[1]=e,i[2]=n,i}function b(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t[2]=e[2]+n[2],t}function E(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t}function A(t,e,n){var i=e[0],r=e[1],s=e[2];return t[0]=i*n[0]+r*n[3]+s*n[6],t[1]=i*n[1]+r*n[4]+s*n[7],t[2]=i*n[2]+r*n[5]+s*n[8],t}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});y();class _{constructor(t){this.nodes=t,this.nodesByIndex=new Map;let e=0,n=0;t.forEach((t=>{t.type!==a.Soma&&(e+=t.radius,n++),this.nodesByIndex.set(t.index,t)})),this.averageRadius=0===n?0:e/n,t.forEach((t=>{0===t.radius&&(t.radius=this.averageRadius)}));const{center:i,bbox:r}=function(t){const[e]=t;if(!e)throw Error("Unable to compute bounding box because the nodes array is empty!");const n=w(e.x,e.y,e.z),i=x(n),r=x(n),s=x(n);let o=1;for(const{x:u,y:l,z:f,index:d,type:v,parent:m}of t){if(d===e.index)continue;const t=w(u,l,f);-1===m&&(c=t,(h=n)[0]=c[0],h[1]=c[1],h[2]=c[2]),v===a.Soma&&(b(s,s,t),o++),i[0]=Math.min(i[0],t[0]),r[0]=Math.max(r[0],t[0]),i[1]=Math.min(i[1],t[1]),r[1]=Math.max(r[1],t[1]),i[2]=Math.min(i[2],t[2]),r[2]=Math.max(r[2],t[2])}var h,c;return function(t,e,n){t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n}(s,s,1/o),E(i,i,s),E(r,r,s),{center:[...s],bbox:[Math.max(Math.abs(i[0]),Math.abs(r[0])),Math.max(Math.abs(i[1]),Math.abs(r[1])),Math.max(Math.abs(i[2]),Math.abs(r[2]))]}}(t);this.center=i,this.bbox=r,this.tree=this.buildTree()}getByIndex(t){return this.nodesByIndex.get(t)}forEach(t){this.nodes.forEach(t)}computeDistancesFromSoma(){const{nodes:t}=this,e=new Map,n=new Map;t.forEach((t=>e.set(t.index,t)));let i=0;if(t.forEach((t=>{const r=M(t,e,n);t.u=r,i=Math.max(i,r)})),0===i)return;const r=1/i;t.forEach((t=>t.u*=r))}buildTree(){const{nodes:t}=this;if(0===t.length)throw Error("There are no nodes in this file!");let[e]=t;const n=new Map;t.forEach((t=>{const i={node:t,children:[]};if(n.set(t.index,i),-1===t.parent)e=t;else if(t.index===t.parent)console.error(`Node #${t.index} has itself has a parent!`);else{const e=n.get(t.parent);e?e.children.push(i):console.error(`Node #${t.index} has #${t.parent} as a parent, which is not yet defined!`)}}));const i=n.get(e.index);if(!i)throw Error("Impossible error! There must be a bug in CellNodes.buildTree().");return i}}function M(t,e,n){if(t.parent<0)return 0;if(n.has(t.index))return n.get(t.index);const i=e.get(t.parent);if(!i)return 0;const r=i.x-t.x,s=i.y-t.y,a=i.z-t.z,o=Math.sqrt(r*r+s*s+a*a)+M(i,e,n);return n.set(t.index,o),o}class B{constructor(t,e=0){this.onChange=t,this._value=0,this._value=e}set(t){this._value!==t&&(this._value=t,this.onChange(this))}get(){return this._value}}class T{constructor(t,e=0,n=0){this.onChange=t,this._width=0,this._height=0,this._width=e,this._height=n}get width(){return this._width}set width(t){t!==this._width&&(this._width=t,this.onChange(this))}get height(){return this._height}set height(t){t!==this._height&&(this._height=t,this.onChange(this))}}class P{constructor(t,e=0,n=0,i=0){this.onChange=t,this._x=0,this._y=0,this._z=0,this._x=e,this._y=n,this._z=i}set([t,e,n]){this._x=t,this._y=e,this._z=n,this.onChange(this)}setYZX([t,e,n]){this._x=e,this._y=n,this._z=t,this.onChange(this)}asArray(){return[this._x,this._y,this._z]}asVec3(){return w(this._x,this._y,this._z)}get x(){return this._x}set x(t){t!==this._x&&(this._x=t,this.onChange(this))}get y(){return this._y}set y(t){t!==this._y&&(this._y=t,this.onChange(this))}get z(){return this._z}set z(t){t!==this._z&&(this._z=t,this.onChange(this))}}function C(){var t=new g(16);return g!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}var R;function U(){var t=new g(9);return g!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function D(){var t=new g(4);return g!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}R=new g(4),g!=Float32Array&&(R[0]=0,R[1]=0,R[2]=0,R[3]=0);y(),w(1,0,0),w(0,1,0),D(),D(),U();const S=w(1,0,0),F=w(0,1,0),I=w(0,0,1);class L{constructor(){this.dirty=!0,this.matrixView=C(),this.matrixProjection=C(),this.orientation=D(),this.axis=U(),this.axisX=y(),this.axisY=y(),this.axisZ=y(),this.position=y(),this.listeners=new Set,this.handleDirty=()=>{this.dirty=!0,this.listeners.forEach((t=>{t()}))},this.distance=new B(this.handleDirty,10),this.target=new P(this.handleDirty,0,0,0),this.viewport=new T(this.handleDirty,1,1),this.near=new B(this.handleDirty,.001),this.far=new B(this.handleDirty,1e6),this.facePosZ()}addEventListener(t,e){this.listeners.add(e)}removeEventListener(t,e){this.listeners.delete(e)}setUniforms(t,e,n){const{matrixView:i,matrixProjection:r}=this;this.updateIfDirty(),t.uniformMatrix4fv(e,!1,i),t.uniformMatrix4fv(n,!1,r)}facePosZ(){var t;(t=this.orientation)[0]=0,t[1]=0,t[2]=0,t[3]=1,this.handleDirty()}rotateAroundXY(t,e){this.updateIfDirty();const{axisX:n,axisY:i,axisZ:r}=this;z(i,n,t),z(r,n,t),z(n,i,e),z(r,i,e),this.axis[0]=n[0],this.axis[1]=n[1],this.axis[2]=n[2],this.axis[3]=i[0],this.axis[4]=i[1],this.axis[5]=i[2],this.axis[6]=r[0],this.axis[7]=r[1],this.axis[8]=r[2],function(t,e){var n,i=e[0]+e[4]+e[8];if(i>0)n=Math.sqrt(i+1),t[3]=.5*n,n=.5/n,t[0]=(e[5]-e[7])*n,t[1]=(e[6]-e[2])*n,t[2]=(e[1]-e[3])*n;else{var r=0;e[4]>e[0]&&(r=1),e[8]>e[3*r+r]&&(r=2);var s=(r+1)%3,a=(r+2)%3;n=Math.sqrt(e[3*r+r]-e[3*s+s]-e[3*a+a]+1),t[r]=.5*n,n=.5/n,t[3]=(e[3*s+a]-e[3*a+s])*n,t[s]=(e[3*s+r]+e[3*r+s])*n,t[a]=(e[3*a+r]+e[3*r+a])*n}}(this.orientation,this.axis),function(t,e){var n=e[0],i=e[1],r=e[2],s=e[3],a=n*n+i*i+r*r+s*s;a>0&&(a=1/Math.sqrt(a)),t[0]=n*a,t[1]=i*a,t[2]=r*a,t[3]=s*a}(this.orientation,this.orientation),this.handleDirty(),console.log(this.orientation.toString())}updateIfDirty(){var t,e,n,i,r,s,a,o,h,c,u,l,f,d,v,m,g,y;this.dirty&&(this.dirty=!1,t=this.axis,c=(n=(e=this.orientation)[0])*(a=n+n),u=(i=e[1])*a,l=i*(o=i+i),f=(r=e[2])*a,d=r*o,v=r*(h=r+r),m=(s=e[3])*a,g=s*o,y=s*h,t[0]=1-l-v,t[3]=u-y,t[6]=f+g,t[1]=u+y,t[4]=1-c-v,t[7]=d-m,t[2]=f-g,t[5]=d+m,t[8]=1-c-l,A(this.axisX,S,this.axis),A(this.axisY,F,this.axis),A(this.axisZ,I,this.axis),function(t,e,n,i){t[0]=e[0]+n[0]*i,t[1]=e[1]+n[1]*i,t[2]=e[2]+n[2]*i}(this.position,this.target.asVec3(),this.axisZ,this.distance.get()),function(t,e,n,i){var r,s,a,o,h,c,u,l,f,d,v=e[0],m=e[1],g=e[2],y=i[0],x=i[1],w=i[2],b=n[0],E=n[1],A=n[2];Math.abs(v-b)<p&&Math.abs(m-E)<p&&Math.abs(g-A)<p?function(t){t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1}(t):(u=v-b,l=m-E,f=g-A,r=x*(f*=d=1/Math.hypot(u,l,f))-w*(l*=d),s=w*(u*=d)-y*f,a=y*l-x*u,(d=Math.hypot(r,s,a))?(r*=d=1/d,s*=d,a*=d):(r=0,s=0,a=0),o=l*a-f*s,h=f*r-u*a,c=u*s-l*r,(d=Math.hypot(o,h,c))?(o*=d=1/d,h*=d,c*=d):(o=0,h=0,c=0),t[0]=r,t[1]=o,t[2]=u,t[3]=0,t[4]=s,t[5]=h,t[6]=l,t[7]=0,t[8]=a,t[9]=c,t[10]=f,t[11]=0,t[12]=-(r*v+s*m+a*g),t[13]=-(o*v+h*m+c*g),t[14]=-(u*v+l*m+f*g),t[15]=1)}(this.matrixView,this.position,this.target.asArray(),this.axisY),function(t,e,n,i,r){var s,a=1/Math.tan(e/2);t[0]=a/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=r&&r!==1/0?(s=1/(i-r),t[10]=(r+i)*s,t[14]=2*r*i*s):(t[10]=-1,t[14]=-2*i)}(this.matrixProjection,Math.PI/2,this.viewport.width/this.viewport.height,this.near.get(),this.far.get()))}}function z(t,e,n){const[i,r,s]=e,a=Math.cos(n),o=Math.sin(n);var h,c,u,l,f,d,v,m,p,y;A(t,t,(h=a+(1-a)*i*i,c=(1-a)*i*r+o*s,u=(1-a)*i*s-o*r,l=(1-a)*i*r-o*s,f=a+(1-a)*r*r,d=(1-a)*r*s+o*i,v=(1-a)*i*s+o*r,m=(1-a)*r*s-o*i,p=a+(1-a)*s*s,(y=new g(9))[0]=h,y[1]=c,y[2]=u,y[3]=l,y[4]=f,y[5]=d,y[6]=v,y[7]=m,y[8]=p,y))}class O{constructor(t){this.options=t,this.start={x:0,y:0,t:0},this.current={x:0,y:0,t:0},this.previous={x:0,y:0,t:0},this.canvas=null,this.active=!1,this.canvasX=0,this.canvasY=0,this.screenX=0,this.screenY=0,this.handleCanvasWheel=t=>{const{onZoom:e}=this.options;e&&(t.preventDefault(),e(t.deltaY))},this.handleCanvasPointerDown=t=>{this.canvasX=t.clientX,this.canvasY=t.clientY,this.active=!0},this.handlePointerDown=t=>{var e,n;if(!this.active)return;this.screenX=t.clientX,this.screenY=t.clientY;const i=this.getPoint(t);this.start=this.current=i,null===(n=(e=this.options).onMoveStart)||void 0===n||n.call(e,i)},this.handlePointerMove=t=>{var e,n;this.active&&this.canvas&&(this.previous=this.current,this.current=this.getPoint(t),null===(n=(e=this.options).onMove)||void 0===n||n.call(e,this))},this.handlePointerUp=t=>{var e,n;this.active&&(null===(n=(e=this.options).onMoveEnd)||void 0===n||n.call(e,this.getPoint(t)),this.active=!1)},t.canvas&&this.attach(t.canvas)}attach(t){this.detach(),this.canvas=t,t.addEventListener("pointerdown",this.handleCanvasPointerDown,!0),t.addEventListener("wheel",this.handleCanvasWheel),document.addEventListener("pointerdown",this.handlePointerDown),document.addEventListener("pointermove",this.handlePointerMove),document.addEventListener("pointerup",this.handlePointerUp)}detach(){const{canvas:t}=this;t&&(t.removeEventListener("pointerdown",this.handleCanvasPointerDown),t.removeEventListener("wheel",this.handleCanvasWheel),document.removeEventListener("pointerdown",this.handlePointerDown),document.removeEventListener("pointermove",this.handlePointerMove),document.removeEventListener("pointerup",this.handlePointerUp),this.canvas=null)}getPoint(t){if(!this.canvas)throw Error("No canvas has been defined!");const{left:e,top:n,width:i,height:r}=this.canvas.getBoundingClientRect();return{x:2*((this.canvasX+t.clientX-this.screenX-e)/i-.5),y:-2*((this.canvasY+t.clientY-this.screenY-n)/r-.5),t:t.timeStamp}}}Math.PI;class Y{constructor(t,e={}){this.camera=t,this.options=e,this.handleZoom=t=>{const e=t>0?1.1:.9,n=this.camera.distance.get();this.camera.distance.set(n*e)},this.handleStart=()=>{},this.handleMove=({previous:t,current:e})=>{const n=e.x-t.x,i=5*(e.y-t.y),r=5*-n;this.camera.rotateAroundXY(i,r)},this.gestures=new O({onMoveStart:this.handleStart,onMove:this.handleMove,onZoom:this.handleZoom})}attach(t){this.gestures.attach(t)}detach(){this.gestures.detach()}}function V(t,e,n){var i;const r=t.createShader("vertex"===e?t.VERTEX_SHADER:t.FRAGMENT_SHADER);if(!r)throw Error("Unable to create a Vertex Shader handle!");t.shaderSource(r,n),t.compileShader(r);const s=null!==(i=t.getShaderInfoLog(r))&&void 0!==i?i:"";if(s.length>0){console.error("Shader error!",s);const t=N(s);throw k(`${e.toUpperCase()} Shader`,n,...t),Error(`Error in ${e.toUpperCase()} shader: ${s}`)}return r}const X=/^ERROR:[ \t]+([0-9]+):([0-9]+):/g;function N(t){const e=[];for(const n of t.split("\n")){X.lastIndex=-1;const t=X.exec(n);t&&e.push(parseInt(t[2],10))}return e}function $(t,e=!1){return`color:#fff;background:${t};font-family:monospace;font-size:80%;font-weight:${e?"bolder":"100"}`}function k(t,e,...n){console.log(`%c${t}`,"font-weight:bolder;font-size:120%"),e.split("\n").forEach(((t,e)=>{const i=e+1,r=(1e-4*i).toFixed(4).substring(2),s=n.includes(i)?"#f00":"#000";console.log(`%c${r}  %c${t}`,$(s),$(s,!0))}))}class W{constructor(t){this.gl=t,this.programs=new Set,this.buffers=new Set}cleanUp(){const{gl:t}=this;this.programs.forEach((({prg:e,shaders:n})=>{n.forEach((e=>t.deleteShader(e))),t.deleteProgram(e)})),this.buffers.forEach((e=>t.deleteBuffer(e)))}createProgram(t){const{prg:e,shaders:n}=function(t,e){var n;const i=t.createProgram();if(!i)throw Error("Unable to create a WebGL program!");const r=V(t,"vertex",e.vert);t.attachShader(i,r);const s=V(t,"fragment",e.frag);if(t.attachShader(i,s),t.linkProgram(i),!t.getProgramParameter(i,t.LINK_STATUS)){const r=null!==(n=t.getProgramInfoLog(i))&&void 0!==n?n:"";console.warn(r);const s=N(r);throw k("Vertex Shader",e.vert,...s),k("Fragment Shader",e.frag,...s),new Error("Could NOT link WebGL2 program!\n"+r)}return{prg:i,shaders:[r,s]}}(this.gl,t);return this.programs.add({prg:e,shaders:n}),e}createBuffer(){const t=this.gl.createBuffer();if(!t)throw Error("Unable to create a WebGLBuffer!");return this.buffers.add(t),t}createVAO(t,...e){const{gl:n}=this,i=n.createVertexArray();if(!i)throw Error("Unable to create VertexArrayObject!");n.bindVertexArray(i);let r=!1;for(const i of e)if("function"==typeof i)i(this);else if(i instanceof Uint8Array||i instanceof Uint16Array||i instanceof Uint32Array){if(r)throw Error("createVAO() can have only one UintArray in the arguments!");r=!0;const t=this.createBuffer();n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t),n.bufferData(n.ELEMENT_ARRAY_BUFFER,i,n.STATIC_DRAW)}else i.buffer||(i.buffer=this.createBuffer()),i.update(n),n.bindBuffer(n.ARRAY_BUFFER,i.buffer),i.define(n,t);return n.bindVertexArray(null),i}getUniformsLocations(t){const{gl:e}=this,n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);if("number"!=typeof n)throw Error("Unable to get the number of uniforms in a WebGLProgram!");const i={};for(let r=0;r<n;r++){const n=e.getActiveUniform(t,r);if(!n)continue;const s=e.getUniformLocation(t,n.name);if(null===s)throw Error(`Unable to get location for uniform "${n.name}"!`);i[n.name]=s}return i}}class Z{constructor(){this._swc=null,this._canvas=null,this.nodes=null,this.paintingIsScheduled=!1,this.painter=null,this.grid=null,this._colorBy="section",this._radiusType=0,this._radiusMultiplier=1,this.paint=()=>{this.paintingIsScheduled||window.requestAnimationFrame(this.actualPaint)},this.actualPaint=t=>{var e,n;this.paintingIsScheduled=!1,null===(e=this.grid)||void 0===e||e.paint(),null===(n=this.painter)||void 0===n||n.paint(t)},this._camera=new L,this.orbiter=new Y(this._camera,{onChange:this.paint})}resetCamera(){this._camera.facePosZ();const{nodes:t}=this;if(t){const[e,n,i]=t.bbox;this._camera.distance.set(i+Math.max(e,n))}}get colorBy(){var t,e;return null!==(e=null===(t=this.painter)||void 0===t?void 0:t.colorBy)&&void 0!==e?e:this._colorBy}set colorBy(t){const{painter:e}=this;this._colorBy=t,e&&(e.colorBy=t)}get radiusType(){var t,e;return null!==(e=null===(t=this.painter)||void 0===t?void 0:t.radiusType)&&void 0!==e?e:this._radiusType}set radiusType(t){const{painter:e}=this;this._radiusType=t,e&&(e.radiusType=t)}get radiusMultiplier(){var t,e;return null!==(e=null===(t=this.painter)||void 0===t?void 0:t.radiusMultiplier)&&void 0!==e?e:this._radiusMultiplier}set radiusMultiplier(t){const{painter:e}=this;this._radiusMultiplier=t,e&&(e.radiusMultiplier=t)}get canvas(){return this._canvas}set canvas(t){t!==this._canvas&&(this._camera.removeEventListener("change",this.paint),this.orbiter.detach(),t&&(this.orbiter.attach(t),this._camera.addEventListener("change",this.paint)),this._canvas=t,this.init())}get swc(){return this._swc}set swc(t){if(t!==this._swc&&(this._swc=t,this.nodes=null,t)){const e=new _(function(t){const e=[];for(const i of n(t)){const t=u(i).split(/\s+/);if(t.length<7)continue;const[n,r,s,o,h,c,f]=t.map((t=>Number(t))),d=r>0&&r<5?r:a.Unknown;e.push({index:n,parent:f,type:d,x:s,y:o,z:h,radius:c,u:0,v:l(d)})}return e}(t));console.log(e.tree),e.computeDistancesFromSoma(),this.nodes=e,this.init()}}init(){const{canvas:t,nodes:e}=this;if(!t||!e)return;this.painter&&this.painter.cleanUp();const n=this._camera,[i,r,s]=e.center,[a,o,h]=e.bbox;n.target.set([i,r,s]),n.distance.set(h+Math.max(a,o));const c=t.getContext("webgl2");if(!c)throw Error("Unable to create WebGL2 context!");const u=new W(c);this.painter=new v(u,e,n),this.grid=new m(u,n)}}var j=e.$;export{j as MorphologyPainter};